<!doctype html>
<html class="no-js" lang="en" data-content_root="">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 7.1.2 and Furo 2024.01.29 -->
        <title>PDielec.Calculator - PDielec: John Kendrick &amp; Andrew Burnett</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../_static/table_styling.css?v=a1a2a898" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=2e0a580d" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">PDielec: John Kendrick & Andrew Burnett</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">PDielec: John Kendrick & Andrew Burnett</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Software</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pdgui.html">PDGui</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software.html">Other Software Components</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../theory_powder.html">Theory for Light Scattering from Powders</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../theory_single_crystal.html">Theory for Single Crystal Optics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../analysis.html">Phonon Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../application_notes_1.html">Applications of Effective Medium Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../application_notes_2.html">Single Crystal Applications</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../autoapi/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../autoapi/PDielec/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec</span></code></a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of PDielec</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../autoapi/PDielec/GUI/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI</span></code></a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of PDielec.GUI</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/AnalysisTab/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.AnalysisTab</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/App/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.App</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/FitterTab/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.FitterTab</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/MainTab/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.MainTab</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/NoteBook/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.NoteBook</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/OpenGLWidget/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.OpenGLWidget</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/PlottingTab/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.PlottingTab</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/PowderScenarioTab/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.PowderScenarioTab</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/ScenarioTab/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.ScenarioTab</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/SettingsTab/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.SettingsTab</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/SingleCrystalLayer/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.SingleCrystalLayer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/SingleCrystalScenarioTab/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.SingleCrystalScenarioTab</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/SpreadSheetManager/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.SpreadSheetManager</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/PDielec/GUI/ViewerTab/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GUI.ViewerTab</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/AbinitOutputReader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.AbinitOutputReader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/Calculator/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.Calculator</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/CastepOutputReader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.CastepOutputReader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/Constants/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.Constants</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/CrystalOutputReader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.CrystalOutputReader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/DielectricFunction/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.DielectricFunction</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/ExperimentOutputReader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.ExperimentOutputReader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/GTMcore/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GTMcore</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/GenericOutputReader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GenericOutputReader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/GulpOutputReader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.GulpOutputReader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/HelperRoutines/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.HelperRoutines</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/IO/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.IO</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/Materials/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.Materials</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/Mie/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.Mie</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/PhonopyOutputReader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.PhonopyOutputReader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/Plotter/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.Plotter</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/QEOutputReader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.QEOutputReader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/SuperCell/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.SuperCell</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/UnitCell/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.UnitCell</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/Utilities/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.Utilities</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/VaspOutputReader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.VaspOutputReader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/checkcsv/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.checkcsv</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/checkexcel/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.checkexcel</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/graphdatagenerator/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.graphdatagenerator</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/p1reader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.p1reader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/p2cif/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.p2cif</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/pdcompare/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.pdcompare</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/pdgui/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.pdgui</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/pdmake/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.pdmake</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/pickled_reader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.pickled_reader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/preader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.preader</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/PDielec/vibanalysis/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.vibanalysis</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/PDielec/pdgui/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.pdgui</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/PDielec/preader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.preader</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/PDielec/pdmake/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PDielec.pdmake</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../zreferences.html">References</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for PDielec.Calculator</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1">#</span>
<span class="c1"># Copyright 2024 John Kendrick &amp; Andrew Burnett</span>
<span class="c1">#</span>
<span class="c1"># This file is part of PDielec</span>
<span class="c1">#</span>
<span class="c1"># This program is free software; you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the MIT License</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the MIT License along with this program, if not see https://opensource.org/licenses/MIT</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;Calculator module.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">cmath</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">lognorm</span>

<span class="c1">#</span>
<span class="c1"># Modify the crossover used in the PyMieScatt Mie routines</span>
<span class="c1"># The Mie routine is taken from PyMieScatt by B. Sumlin and can be found on github</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">PDielec</span> <span class="kn">import</span> <span class="n">Mie</span>
<span class="kn">from</span> <span class="nn">PDielec.Constants</span> <span class="kn">import</span> <span class="n">d2byamuang2</span>

<span class="n">Mie</span><span class="o">.</span><span class="n">crossover</span> <span class="o">=</span> <span class="mf">0.01</span>

<div class="viewcode-block" id="initialise_unit_tensor"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.initialise_unit_tensor">[docs]</a><span class="k">def</span> <span class="nf">initialise_unit_tensor</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialise a 3x3 tensor to a unit tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array</span>
<span class="sd">        The returned tensor is a 3x3 array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="initialise_complex_diagonal_tensor"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.initialise_complex_diagonal_tensor">[docs]</a><span class="k">def</span> <span class="nf">initialise_complex_diagonal_tensor</span><span class="p">(</span><span class="n">reals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialise a complex 3x3 tensor with the given diagonal components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reals : list</span>
<span class="sd">        A list of 3 real numbers for the diagonals.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array</span>
<span class="sd">        The returned tensor is a complex 3x3 array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="initialise_diagonal_tensor"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.initialise_diagonal_tensor">[docs]</a><span class="k">def</span> <span class="nf">initialise_diagonal_tensor</span><span class="p">(</span><span class="n">reals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialise a real 3x3 tensor with the given diagonal components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reals : list</span>
<span class="sd">        A list of 3 real numbers for the diagonals.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array</span>
<span class="sd">        The returned tensor is a real 3x3 array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="calculate_distance"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.calculate_distance">[docs]</a><span class="k">def</span> <span class="nf">calculate_distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the distance between a and b.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : list of reals</span>
<span class="sd">        Coordinates of a</span>
<span class="sd">    b : list of reals</span>
<span class="sd">        Coordinates of b</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The distance between a and b</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>


<div class="viewcode-block" id="calculate_angle"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.calculate_angle">[docs]</a><span class="k">def</span> <span class="nf">calculate_angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the angle between a, b and c in degrees.</span>

<span class="sd">    The bond is a-b-c, b is the central atom</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : list of reals</span>
<span class="sd">        Coordinates of a</span>
<span class="sd">    b : list of reals</span>
<span class="sd">        Coordinates of b</span>
<span class="sd">    c : list of reals</span>
<span class="sd">        Coordinates of c</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The angle between a-b-c in degrees</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">ba</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">b</span>
    <span class="n">ba</span> <span class="o">=</span> <span class="n">ba</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ba</span><span class="p">)</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="n">bc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span><span class="n">bc</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span></div>

<div class="viewcode-block" id="calculate_torsion"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.calculate_torsion">[docs]</a><span class="k">def</span> <span class="nf">calculate_torsion</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the torsion angle between a, b, c and d in degrees.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : list of reals</span>
<span class="sd">        Coordinates of a</span>
<span class="sd">    b : list of reals</span>
<span class="sd">        Coordinates of b</span>
<span class="sd">    c : list of reals</span>
<span class="sd">        Coordinates of c</span>
<span class="sd">    d : list of reals</span>
<span class="sd">        Coordinates of d</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The torsion angle between a-b-c-d in degrees</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="c1"># There are 3 bonds</span>
    <span class="n">a_ba</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">b_cb</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">b</span>
    <span class="n">c_dc</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">c</span>
    <span class="c1"># Calculate the perpendicular to abc and bcd</span>
    <span class="n">axb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span> <span class="n">a_ba</span><span class="p">,</span> <span class="n">b_cb</span><span class="p">)</span>
    <span class="n">bxc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span> <span class="n">c_dc</span><span class="p">,</span> <span class="n">b_cb</span><span class="p">)</span>
    <span class="n">abc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">axb</span><span class="p">,</span><span class="n">bxc</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">abc</span><span class="p">,</span><span class="n">b_cb</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b_cb</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">axb</span><span class="p">,</span><span class="n">bxc</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="initialise_sphere_depolarisation_matrix"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.initialise_sphere_depolarisation_matrix">[docs]</a><span class="k">def</span> <span class="nf">initialise_sphere_depolarisation_matrix</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialise a 3x3 tensor with the sphere depolarisation matrix, returns a tensor.</span>

<span class="sd">    Parmeters</span>
<span class="sd">    ---------</span>
<span class="sd">    None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 3x3 tensor representing the sphere depolarisation matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">athird</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="n">tensor</span> <span class="o">=</span> <span class="n">initialise_diagonal_tensor</span><span class="p">([</span><span class="n">athird</span><span class="p">,</span> <span class="n">athird</span><span class="p">,</span> <span class="n">athird</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">tensor</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span></div>

<div class="viewcode-block" id="initialise_plate_depolarisation_matrix"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.initialise_plate_depolarisation_matrix">[docs]</a><span class="k">def</span> <span class="nf">initialise_plate_depolarisation_matrix</span><span class="p">(</span><span class="n">normal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialise a 3x3 tensor with the plate depolarisation matrix, returns a tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    normal : np.array</span>
<span class="sd">        A 3 vector giving the normal direction of the plate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 3x3 tensor initialized with the plate depolarisation matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
    <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tensor</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span></div>

<div class="viewcode-block" id="initialise_needle_depolarisation_matrix"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.initialise_needle_depolarisation_matrix">[docs]</a><span class="k">def</span> <span class="nf">initialise_needle_depolarisation_matrix</span><span class="p">(</span><span class="n">unique</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialise a 3x3 tensor with the needle depolarisation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unique: np.array</span>
<span class="sd">        The unique direction of the needle</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 3x3 tensor initialized with the plate depolarisation matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># unique is the unique direction of the needle</span>
    <span class="c1"># depolarisation matrix is therefore half the sum of the</span>
    <span class="c1"># two outer products of the directions perpendicular to it</span>
    <span class="n">unique</span> <span class="o">=</span> <span class="n">unique</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">xdotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unique</span><span class="p">)</span>
    <span class="n">ydotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">unique</span><span class="p">)</span>
    <span class="n">zdotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">unique</span><span class="p">)</span>
    <span class="n">absxdotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xdotn</span><span class="p">)</span>
    <span class="n">absydotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ydotn</span><span class="p">)</span>
    <span class="n">abszdotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zdotn</span><span class="p">)</span>
    <span class="c1"># choose the direction with the smallest projection along the needle</span>
    <span class="c1"># then project out any needle direction</span>
    <span class="k">if</span> <span class="n">absxdotn</span> <span class="o">&lt;=</span> <span class="n">absydotn</span> <span class="ow">and</span> <span class="n">absxdotn</span> <span class="o">&lt;=</span> <span class="n">abszdotn</span><span class="p">:</span>
        <span class="n">dir1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">xdotn</span> <span class="o">*</span> <span class="n">unique</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">absydotn</span> <span class="o">&lt;=</span> <span class="n">absxdotn</span> <span class="ow">and</span> <span class="n">absydotn</span> <span class="o">&lt;=</span> <span class="n">abszdotn</span><span class="p">:</span>
        <span class="n">dir1</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">ydotn</span> <span class="o">*</span> <span class="n">unique</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dir1</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="p">(</span><span class="n">zdotn</span> <span class="o">*</span> <span class="n">unique</span><span class="p">)</span>
    <span class="n">dir1</span> <span class="o">=</span> <span class="n">dir1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dir1</span><span class="p">)</span>
    <span class="c1"># now find the orthogonal direction</span>
    <span class="n">dir2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span> <span class="n">dir1</span><span class="p">)</span>
    <span class="n">dir2</span> <span class="o">=</span> <span class="n">dir2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dir2</span><span class="p">)</span>
    <span class="c1"># compute the complex tensors from the outer product of each direction</span>
    <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dir1</span><span class="p">,</span> <span class="n">dir1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dir2</span><span class="p">,</span> <span class="n">dir2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tensor</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span></div>

<div class="viewcode-block" id="initialise_ellipsoid_depolarisation_matrix"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.initialise_ellipsoid_depolarisation_matrix">[docs]</a><span class="k">def</span> <span class="nf">initialise_ellipsoid_depolarisation_matrix</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span> <span class="n">aoverb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialise a 3x3 tensor with the ellipsoid depolarisation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unique : list of 3 floats</span>
<span class="sd">        Unique direction for ellipsoid</span>
<span class="sd">    aoverb : float</span>
<span class="sd">        The ratio of a / b (the ratio of the principle axis lengths of the ellipsoid)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        The Ellipsoid dpolarisation tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># unique is the unique direction of the ellipsoid</span>
    <span class="c1"># a and b are the sizes of the ellipsoid along the unique axis (a) and perpendicular to it b</span>
    <span class="c1"># if a &gt; b then we have a prolate ellipsoid</span>
    <span class="n">unique</span> <span class="o">=</span> <span class="n">unique</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">xdotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unique</span><span class="p">)</span>
    <span class="n">ydotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">unique</span><span class="p">)</span>
    <span class="n">zdotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">unique</span><span class="p">)</span>
    <span class="n">absxdotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xdotn</span><span class="p">)</span>
    <span class="n">absydotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ydotn</span><span class="p">)</span>
    <span class="n">abszdotn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zdotn</span><span class="p">)</span>
    <span class="c1"># choose the direction with the smallest projection along the ellipsoid</span>
    <span class="c1"># then project out any ellipsoid direction</span>
    <span class="k">if</span> <span class="n">absxdotn</span> <span class="o">&lt;=</span> <span class="n">absydotn</span> <span class="ow">and</span> <span class="n">absxdotn</span> <span class="o">&lt;=</span> <span class="n">abszdotn</span><span class="p">:</span>
        <span class="n">dir1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">xdotn</span> <span class="o">*</span> <span class="n">unique</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">absydotn</span> <span class="o">&lt;=</span> <span class="n">absxdotn</span> <span class="ow">and</span> <span class="n">absydotn</span> <span class="o">&lt;=</span> <span class="n">abszdotn</span><span class="p">:</span>
        <span class="n">dir1</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">ydotn</span> <span class="o">*</span> <span class="n">unique</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dir1</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="p">(</span><span class="n">zdotn</span> <span class="o">*</span> <span class="n">unique</span><span class="p">)</span>
    <span class="n">dir1</span> <span class="o">=</span> <span class="n">dir1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dir1</span><span class="p">)</span>
    <span class="c1"># now find the orthogonal direction</span>
    <span class="n">dir2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span> <span class="n">dir1</span><span class="p">)</span>
    <span class="n">dir2</span> <span class="o">=</span> <span class="n">dir2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dir2</span><span class="p">)</span>
    <span class="n">bovera</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">aoverb</span>
    <span class="n">small</span> <span class="o">=</span> <span class="mf">1.0E-8</span>
    <span class="k">if</span> <span class="n">bovera</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="o">-</span><span class="n">small</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span>  <span class="o">-</span> <span class="n">bovera</span><span class="o">*</span><span class="n">bovera</span><span class="p">)</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">e</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">e</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">e</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">e</span><span class="o">*</span><span class="n">e</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">bovera</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="o">+</span><span class="n">small</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bovera</span><span class="o">*</span><span class="n">bovera</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">e</span><span class="o">*</span><span class="n">e</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span>
    <span class="n">nxy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nz</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="c1">#</span>
    <span class="c1"># compute the tensors from the outer product of each direction</span>
    <span class="n">tensor</span> <span class="o">=</span> <span class="n">nz</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span> <span class="n">unique</span><span class="p">)</span> <span class="o">+</span> <span class="n">nxy</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dir1</span><span class="p">,</span> <span class="n">dir1</span><span class="p">)</span> <span class="o">+</span> <span class="n">nxy</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dir2</span><span class="p">,</span> <span class="n">dir2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tensor</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">fibonacci_sphere</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">randomize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate points on a sphere using the Fibonacci lattice method.</span>

<span class="sd">    This method generates points on the surface of a sphere in a way that they are evenly distributed. The distribution follows</span>
<span class="sd">    the Fibonacci Sphere algorithm, which is useful for creating well-distributed points across the surface of a sphere.</span>
<span class="sd">    Optionally, the points can be randomized slightly to avoid patterns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    samples : int, optional</span>
<span class="sd">        The number of points to generate on the sphere. Default is 1.</span>
<span class="sd">    randomize : bool, optional</span>
<span class="sd">        If `True`, the points generation will include a random factor to slightly change the distribution of points.</span>
<span class="sd">        This can be useful to avoid symmetric patterns. Default is `True`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of points where each point is represented as a list `[x, y, z]`, indicating its position on the sphere.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The algorithm works by placing points at equal distances along a spiral around the sphere.</span>
<span class="sd">    - The `randomize` option applies a random offset to the spiral, which can help in reducing visual patterns in the distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate 100 points on a sphere without randomization:</span>

<span class="sd">    &gt;&gt;&gt; points = fibonacci_sphere(100, randomize=False)</span>
<span class="sd">    &gt;&gt;&gt; len(points)</span>
<span class="sd">    100</span>

<span class="sd">    Generate 5 points on a sphere with default settings (including randomization):</span>

<span class="sd">    &gt;&gt;&gt; points = fibonacci_sphere(5)</span>
<span class="sd">    &gt;&gt;&gt; len(points)</span>
<span class="sd">    5</span>

<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">rnd</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">if</span> <span class="n">randomize</span><span class="p">:</span>
        <span class="n">rnd</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="n">samples</span>

    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">/</span><span class="n">samples</span>
    <span class="n">increment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">5.</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">*</span> <span class="n">offset</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">rnd</span><span class="p">)</span> <span class="o">%</span> <span class="n">samples</span><span class="p">)</span> <span class="o">*</span> <span class="n">increment</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span>

        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">points</span>

<div class="viewcode-block" id="ionic_permittivity"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.ionic_permittivity">[docs]</a><span class="k">def</span> <span class="nf">ionic_permittivity</span><span class="p">(</span><span class="n">mode_list</span><span class="p">,</span> <span class="n">oscillator_strengths</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">volume</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the low frequency permittivity or zero frequency permittivity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mode_list : list</span>
<span class="sd">        List of integers giving the active modes</span>
<span class="sd">    oscillator_strengths : array_like</span>
<span class="sd">        Oscillator strengths, in atomic units.</span>
<span class="sd">    frequencies : array_like</span>
<span class="sd">        Frequencies, in atomic units.</span>
<span class="sd">    volume : float</span>
<span class="sd">        Volume, in atomic units.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    3x3 np.array </span>
<span class="sd">        The calculated low frequency permittivity or zero frequency permittivity.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The calculation of low frequency permittivity or zero frequency permittivity</span>
<span class="sd">    requires oscillator strengths, frequencies, and volume all to be specified</span>
<span class="sd">    in atomic units. </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">permittivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">imode</span> <span class="ow">in</span> <span class="n">mode_list</span><span class="p">:</span>
        <span class="n">permittivity</span> <span class="o">=</span> <span class="n">permittivity</span> <span class="o">+</span> <span class="n">oscillator_strengths</span><span class="p">[</span><span class="n">imode</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">frequencies</span><span class="p">[</span><span class="n">imode</span><span class="p">]</span> <span class="o">*</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">imode</span><span class="p">])</span>
    <span class="c1"># end for</span>
    <span class="k">return</span> <span class="n">permittivity</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">volume</span><span class="p">)</span></div>

<div class="viewcode-block" id="infrared_intensities"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.infrared_intensities">[docs]</a><span class="k">def</span> <span class="nf">infrared_intensities</span><span class="p">(</span><span class="n">oscillator_strengths</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the IR intensities from the trace of the oscillator strengths.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        An array of the calculated IR intensities in units of (D/A)^2/amu.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Each mode has a 3x3 oscillator strength</span>
    <span class="n">nmodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">oscillator_strengths</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nmodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">imode</span><span class="p">,</span> <span class="n">strength</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">oscillator_strengths</span><span class="p">):</span>
        <span class="c1"># We calculate the intensity from the trace of the strengths</span>
        <span class="n">intensities</span><span class="p">[</span><span class="n">imode</span><span class="p">]</span> <span class="o">=</span> <span class="n">intensities</span><span class="p">[</span><span class="n">imode</span><span class="p">]</span> <span class="o">+</span> <span class="n">strength</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">strength</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">strength</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c1"># end for</span>
    <span class="n">maxintensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">intensities</span><span class="p">)</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="n">maxintensity</span>
    <span class="c1"># convert the intensities to Castep units (D/A)**2/amu</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="n">d2byamuang2</span>
    <span class="k">return</span> <span class="n">intensities</span> <span class="o">/</span> <span class="n">convert</span></div>

<div class="viewcode-block" id="longitudinal_modes"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.longitudinal_modes">[docs]</a><span class="k">def</span> <span class="nf">longitudinal_modes</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">normal_modes</span><span class="p">,</span> <span class="n">born_charges</span><span class="p">,</span> <span class="n">masses</span><span class="p">,</span> <span class="n">epsilon_inf</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply the nonanalytic correction to the dynamical matrix and calculate the LO frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : array_like</span>
<span class="sd">        The frequencies (f) in atomic units.</span>
<span class="sd">    normal_modes : array_like</span>
<span class="sd">        The mass weighted normal modes (U).</span>
<span class="sd">    born_charges : array_like</span>
<span class="sd">        The born charges (Z) stored as</span>
<span class="sd">        `[[Z1x, Z1y, Z1z], [Z2x, Z2y, Z2z], [Z3x, Z3y, Z3z]]`,</span>
<span class="sd">        where 1, 2, 3 are the directions of the field and x, y, z are the coordinates of the atom.</span>
<span class="sd">    masses : array_like</span>
<span class="sd">        The atomic masses in atomic units</span>
<span class="sd">    epsilon_inf : 3x3 array</span>
<span class="sd">        Epsilon infinity</span>
<span class="sd">    volume : float</span>
<span class="sd">        volume in atomic units</span>
<span class="sd">    qlist : list</span>
<span class="sd">        A list of direction vectors.</span>
<span class="sd">    reader : a reader object</span>
<span class="sd">        a reader object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of (real) frequencies in atomic units. Any imaginary frequencies are set to 0.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If projection was requested in the reader, the correction is modified to ensure translational invariance.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use a sqrt that returns a complex number</span>
    <span class="c1"># from numpy.lib.scimath import sqrt</span>
    <span class="c1"># First step is to reconstruct the dynamical matrix (D) from the frequencies and the eigenvectors</span>
    <span class="c1"># f^2 = UT . D . U</span>
    <span class="c1"># and U is a hermitian matrix so U-1 = UT</span>
    <span class="c1"># D = (UT)-1 f^2 U-1 = U f UT</span>
    <span class="c1"># Construct UT from the normal modes</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">normal_modes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">normal_modes</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span>
    <span class="n">UT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">imode</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">normal_modes</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
            <span class="c1"># in python the first index is the row of the matrix, the second is the column</span>
            <span class="n">UT</span><span class="p">[</span><span class="n">imode</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">UT</span><span class="p">[</span><span class="n">imode</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">UT</span><span class="p">[</span><span class="n">imode</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">3</span>
        <span class="c1"># end for atom</span>
    <span class="c1"># end for imode</span>
    <span class="c1"># zero the nonanalytical correction</span>
    <span class="n">Wm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="c1"># convert the frequencies^2 to a real diagonal array</span>
    <span class="c1"># Warning we have to make sure the sign is correct here</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">frequencies</span><span class="o">*</span><span class="n">frequencies</span><span class="p">))</span>
    <span class="n">Dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">UT</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">f2</span><span class="p">),</span> <span class="n">UT</span><span class="p">)</span>
    <span class="c1"># Make sure the dynamical matrix is real</span>
    <span class="n">Dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Dm</span><span class="p">)</span>
    <span class="c1"># Find its eigenvalues</span>
    <span class="n">eig_val</span><span class="p">,</span> <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Dm</span><span class="p">)</span>
    <span class="c1"># Store the results for returning to the main program</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Loop over q values</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qlist</span><span class="p">:</span>
        <span class="c1"># Now calculate the nonanalytic part</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">epsilon_inf</span><span class="p">),</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">volume</span><span class="p">)</span>
        <span class="c1"># Loop over atom a</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">za</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">born_charges</span><span class="p">):</span>
            <span class="c1"># atom is the atom index</span>
            <span class="c1"># born contains the polarisability tensor [z1x z1y z1z] [z2x z2y z2z] [z3x z3y z3z]]</span>
            <span class="c1"># where 1, 2, 3 are the directions of the field and x, y, z are the coordinates of the atom</span>
            <span class="n">za</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">za</span><span class="p">)</span>
            <span class="c1"># Loop over atom b</span>
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">zb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">born_charges</span><span class="p">):</span>
                <span class="n">zb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">zb</span><span class="p">)</span>
                <span class="n">terms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">za</span><span class="p">,</span> <span class="n">zb</span><span class="p">)</span> <span class="o">*</span> <span class="n">constant</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">masses</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">*</span><span class="n">masses</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="mi">3</span>
                <span class="k">for</span> <span class="n">termi</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="mi">3</span>
                    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">termi</span><span class="p">:</span>
                        <span class="n">Wm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">term</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="c1"># end for term</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># end for i</span>
            <span class="c1"># end loop over b</span>
        <span class="c1"># end loop over a</span>
        <span class="c1"># Construct the full dynamical matrix with the correction</span>
        <span class="n">Dmq</span> <span class="o">=</span> <span class="n">Dm</span> <span class="o">+</span> <span class="n">Wm</span>
        <span class="c1"># If projection was requested when the matrix was read, project out translation</span>
        <span class="k">if</span> <span class="n">reader</span><span class="o">.</span><span class="n">eckart</span><span class="p">:</span>
            <span class="n">reader</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">Dmq</span><span class="p">)</span>
        <span class="n">eig_val</span><span class="p">,</span> <span class="n">eig_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Dmq</span><span class="p">)</span>
        <span class="c1"># If eig_val less than zero we set it to zero</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">eig</span> <span class="ow">in</span> <span class="n">eig_val</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">eig</span><span class="p">)</span> <span class="k">if</span> <span class="n">eig</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">eig</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="c1"># end of for eig</span>
        <span class="c1"># Sort the eigen values in ascending order and append to the results</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
    <span class="c1"># end loop over q</span>
    <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="oscillator_strengths"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.oscillator_strengths">[docs]</a><span class="k">def</span> <span class="nf">oscillator_strengths</span><span class="p">(</span><span class="n">normal_modes</span><span class="p">,</span> <span class="n">born_charges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate oscillator strengths from the normal modes and the born charges.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    normal_modes : array_like</span>
<span class="sd">        Normal modes are in the mass weighted coordinate system and normalized.</span>
<span class="sd">    born_charges : array_like</span>
<span class="sd">        Born charges are in electrons, so in atomic units.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        Oscillator strengths calculated from the given normal modes and born charges.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Each mode has a 3x3 oscillator strength</span>
    <span class="n">nmodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">normal_modes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">oscillator_strengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">imode</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">normal_modes</span><span class="p">):</span>
        <span class="c1"># We calculate the dipole induced by displacement of each atom along the normal mode</span>
        <span class="n">z_imode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">born</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">born_charges</span><span class="p">):</span>
            <span class="c1"># atom is the atom index</span>
            <span class="c1"># born contains the polarisability tensor [a1x a1y a1z] [a2x a2y a2z] [a3x a3y a3z]]</span>
            <span class="c1"># where 1, 2, 3 are the directions of the field and x, y, z are the coordinates of the atom</span>
            <span class="n">z_imode</span> <span class="o">=</span> <span class="n">z_imode</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">born</span><span class="p">,</span> <span class="n">mode</span><span class="p">[</span><span class="n">atom</span><span class="p">])</span>  <span class="c1"># the displacement is an array [x, y, z]</span>
        <span class="c1"># end for</span>
        <span class="c1"># The oscillator strength matrix is the outer product of z</span>
        <span class="n">oscillator_strengths</span><span class="p">[</span><span class="n">imode</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">z_imode</span><span class="p">,</span> <span class="n">z_imode</span><span class="p">)</span>
    <span class="c1"># end for</span>
    <span class="k">return</span> <span class="n">oscillator_strengths</span></div>

<div class="viewcode-block" id="normal_modes"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.normal_modes">[docs]</a><span class="k">def</span> <span class="nf">normal_modes</span><span class="p">(</span><span class="n">masses</span><span class="p">,</span> <span class="n">mass_weighted_normal_modes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform from mass weighted coordinates to xyz.</span>

<span class="sd">    Note this returns an array object. The returned normal modes have NOT been renormalized.</span>
<span class="sd">    The input masses are in atomic units. The output normal modes are in atomic units.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    masses : array of floats</span>
<span class="sd">        The masses in atomic units</span>
<span class="sd">    mass_weighted_normal_modes : array of floats</span>
<span class="sd">        The mass weighted normal modes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        An array of xyz coordinates derived from mass-weighted coordinates.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The transformation to xyz coordinates does not involve renormalization of the normal modes.</span>
<span class="sd">    Both the input masses and the output normal modes are in atomic units.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">list_m</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">normal_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mass_weighted_normal_modes</span><span class="p">)</span>
    <span class="n">nions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">masses</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nions</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">masses</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
        <span class="n">list_m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
    <span class="c1"># end of loop of ions</span>
    <span class="n">array_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_m</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mass_weighted_normal_modes</span><span class="p">):</span>
        <span class="n">normal_modes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">*</span> <span class="n">array_m</span>
    <span class="k">return</span> <span class="n">normal_modes</span></div>

<div class="viewcode-block" id="rodridgues_rotations"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.rodridgues_rotations">[docs]</a><span class="k">def</span> <span class="nf">rodridgues_rotations</span><span class="p">(</span><span class="n">efield</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take the field directions in efield and use each direction to calculate a random rotation about that axis.</span>

<span class="sd">    Use the field (which is a random unit vector in xyz space) to generate an orthogonal rotation matrix</span>
<span class="sd">    using the Rodrigues rotation formula A = I3.cos(theta) + (1-cos(theta)) e . eT + ex sin(theta),</span>
<span class="sd">    where I3 is a unit matrix, e is the direction, and ex is the cross product matrix:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\begin{align}</span>
<span class="sd">        &amp;\\text{ex} = \\begin{pmatrix} 0 &amp; -e3 &amp; e2 \\\\ e3 &amp; 0 &amp; -e1 \\\\ -e2 &amp; e1 &amp; 0 \\end{pmatrix}</span>
<span class="sd">        \\end{align}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    efield : array_like</span>
<span class="sd">        The field directions, where each direction is used to calculate a random rotation about that axis. Assumes the field is real.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of ndarray</span>
<span class="sd">        A list of rotation matrices for each direction in efield.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The input field is assumed to be real.</span>
<span class="sd">    - Output is a list of 3x3 rotation matrices.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rotations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">efield</span><span class="p">:</span>
        <span class="c1"># Calculate a random angle between 0 and 180</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
        <span class="n">cos</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">sin</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">e3</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">)</span><span class="o">*</span><span class="n">e1</span><span class="o">*</span><span class="n">e1</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">)</span><span class="o">*</span><span class="n">e2</span><span class="o">*</span><span class="n">e1</span> <span class="o">+</span> <span class="n">sin</span><span class="o">*</span><span class="n">e3</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">)</span><span class="o">*</span><span class="n">e3</span><span class="o">*</span><span class="n">e1</span> <span class="o">-</span> <span class="n">sin</span><span class="o">*</span><span class="n">e2</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">)</span><span class="o">*</span><span class="n">e1</span><span class="o">*</span><span class="n">e2</span> <span class="o">-</span> <span class="n">sin</span><span class="o">*</span><span class="n">e3</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">)</span><span class="o">*</span><span class="n">e2</span><span class="o">*</span><span class="n">e2</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">)</span><span class="o">*</span><span class="n">e3</span><span class="o">*</span><span class="n">e2</span> <span class="o">+</span> <span class="n">sin</span><span class="o">*</span><span class="n">e1</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">)</span><span class="o">*</span><span class="n">e1</span><span class="o">*</span><span class="n">e3</span> <span class="o">+</span> <span class="n">sin</span><span class="o">*</span><span class="n">e2</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">)</span><span class="o">*</span><span class="n">e2</span><span class="o">*</span><span class="n">e3</span> <span class="o">-</span> <span class="n">sin</span><span class="o">*</span><span class="n">e1</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">)</span><span class="o">*</span><span class="n">e3</span><span class="o">*</span><span class="n">e3</span>
        <span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rotations</span></div>

<div class="viewcode-block" id="absorption_from_mode_intensities"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.absorption_from_mode_intensities">[docs]</a><span class="k">def</span> <span class="nf">absorption_from_mode_intensities</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">,</span> <span class="n">intensities</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the absorption from the frequencies and intensities using a Lorentzian.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : float</span>
<span class="sd">        The frequency of the absorption in cm-1.</span>
<span class="sd">    modes : list of ints</span>
<span class="sd">        A list of the modes </span>
<span class="sd">    frequencies : list of reals</span>
<span class="sd">        Mode frequencies (cm-1)</span>
<span class="sd">    sigmas : list of reals</span>
<span class="sd">        Mode widths in cm-1</span>
<span class="sd">    intensities : list of reals</span>
<span class="sd">        Mode intensities (D2/A2/amu).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The molar absorption coefficient at f, in L/mol/cm.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The number 4225.6 converts the units of D2/A2/amu to L mole-1 cm-1 cm-1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">absorption</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">frequencies</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigmas</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">icastep</span> <span class="o">=</span> <span class="n">intensities</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">absorption</span> <span class="o">=</span> <span class="n">absorption</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="mf">4225.6</span> <span class="o">*</span> <span class="n">icastep</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">/</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">absorption</span></div>

<div class="viewcode-block" id="calculate_size_factor"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.calculate_size_factor">[docs]</a><span class="k">def</span> <span class="nf">calculate_size_factor</span> <span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate a size effect using Equations 10.38 and 10.39 in Sihvola.</span>

<span class="sd">    If x is small the result is  close to 1</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">       The size of the particle</span>
<span class="sd"> </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Size effect</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">1.0E-12</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">ix</span> <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ix</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="p">)</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ix</span> <span class="o">-</span> <span class="p">(</span><span class="mf">7.0</span><span class="o">/</span><span class="mf">15.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="mf">15.0</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ix</span><span class="p">)</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">g1</span> <span class="o">-</span> <span class="n">g2</span>
    <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="averaged_permittivity"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.averaged_permittivity">[docs]</a><span class="k">def</span> <span class="nf">averaged_permittivity</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective constant permittivity using the averaged permittivity method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric_medium : array_like (3x3)</span>
<span class="sd">        The dielectric constant tensor of the medium.</span>
<span class="sd">    crystal_permittivity : array_like (3x3)</span>
<span class="sd">        The total frequency dielectric constant tensor at the current frequency.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The name of the current shape.</span>
<span class="sd">    L : array_like (3x3)</span>
<span class="sd">        The shape&#39;s depolarisation matrix.</span>
<span class="sd">    vf : float</span>
<span class="sd">        Volume fraction</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration (not used).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        The effective dielectric constant.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">effd</span> <span class="o">=</span> <span class="n">vf</span> <span class="o">*</span> <span class="n">crystal_permittivity</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">vf</span><span class="p">)</span> <span class="o">*</span> <span class="n">dielectric_medium</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">effd</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">]])</span></div>

<div class="viewcode-block" id="balan"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.balan">[docs]</a><span class="k">def</span> <span class="nf">balan</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective constant permittivity using the method of Balan.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric_medium : array_like (3x3)</span>
<span class="sd">        The dielectric constant tensor of the medium.</span>
<span class="sd">    crystal_permittivity : array_like (3x3)</span>
<span class="sd">        The total frequency dielectric constant tensor at the current frequency.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The name of the current shape.</span>
<span class="sd">    L : array_like (3x3)</span>
<span class="sd">        The shape&#39;s depolarisation matrix.</span>
<span class="sd">    vf : float</span>
<span class="sd">        Volume fraction</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration (not used).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        The effective dielectric constant.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">initialise_unit_tensor</span><span class="p">()</span>
    <span class="n">dielecvm1</span> <span class="o">=</span> <span class="p">(</span><span class="n">crystal_permittivity</span> <span class="o">-</span> <span class="n">unit</span><span class="p">)</span>
    <span class="n">deformation</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">dielectric_medium</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">crystal_permittivity</span> <span class="o">-</span> <span class="n">dielectric_medium</span><span class="p">))))</span>
    <span class="n">effd</span>          <span class="o">=</span> <span class="n">unit</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">deformation</span><span class="p">,</span> <span class="n">dielecvm1</span><span class="p">)</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">vf</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">effd</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">]])</span></div>

<span class="k">def</span> <span class="nf">spherical_averaged_mie_scattering</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">size_mu</span><span class="p">,</span> <span class="n">size_distribution_sigma</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective constant permittivity using a Mie scattering approach.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric_medium : array_like (3x3)</span>
<span class="sd">        The dielectric constant tensor of the medium.</span>
<span class="sd">    crystal_permittivity : array_like (3x3)</span>
<span class="sd">        The total frequency dielectric constant tensor at the current frequency.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The name of the current shape. This parameter is ignored as Mie scattering </span>
<span class="sd">        only works for spherical particles.</span>
<span class="sd">    L : array_like (3x3)</span>
<span class="sd">        The shape&#39;s depolarisation matrix. This parameter is ignored as Mie scattering</span>
<span class="sd">        only works for spherical particles.</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration.</span>
<span class="sd">    size_mu : float</span>
<span class="sd">        The size in microns</span>
<span class="sd">    size_distribution_sigma : float</span>
<span class="sd">        The log normal value of sigma.</span>
<span class="sd">    vf : float</span>
<span class="sd">        The volume fraction of filler.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The effective dielectric constant. This is calculated by accounting for </span>
<span class="sd">        the anisotropy of the permittivity through sampling many directions </span>
<span class="sd">        and calculating the scattering in each direction.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Mie scattering is applicable only to spherical particles, hence parameters such </span>
<span class="sd">    as `shape` and `L` are not used in this calculation. The routine considers the </span>
<span class="sd">    anisotropy of the permittivity by sampling various directions and computing </span>
<span class="sd">    the scattering for each to calculate the effective dielectric constant.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points_on_sphere</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># define i as a complex number</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># We need to taken account of the change in wavelength and the change in size parameter due to the</span>
    <span class="c1"># None unit value of the dielectric of the embedding medium</span>
    <span class="c1"># The size parameter is 2pi r / lambda</span>
    <span class="c1"># The effective lambda in the supporting medium is lambda / sqrt(emedium)</span>
    <span class="c1"># Where the refractive index is taken to be sqrt(emedium) (non magnetic materials)</span>
    <span class="n">emedium</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="n">refractive_index_medium</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">emedium</span><span class="p">))</span>
    <span class="n">lambda_vacuum_mu</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">size_mu</span> <span class="o">/</span> <span class="n">size</span>
    <span class="n">wavelength_nm</span> <span class="o">=</span> <span class="n">lambda_vacuum_mu</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">refractive_index_medium</span>
    <span class="n">radius_nm</span> <span class="o">=</span> <span class="n">size_mu</span> <span class="o">*</span> <span class="mi">1000</span>
    <span class="c1"># The wavevector in nm-1</span>
    <span class="n">k_nm</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">wavelength_nm</span>
    <span class="c1"># volume of a particle in nm^3</span>
    <span class="n">V_nm</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">/</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius_nm</span> <span class="o">*</span> <span class="n">radius_nm</span> <span class="o">*</span> <span class="n">radius_nm</span>
    <span class="c1"># Number density of particles (number / nm^3)</span>
    <span class="n">N_nm</span> <span class="o">=</span> <span class="n">vf</span> <span class="o">/</span> <span class="n">V_nm</span>
    <span class="c1"># If there is a size distribution set up to use it</span>
    <span class="k">if</span> <span class="n">size_distribution_sigma</span><span class="p">:</span>
        <span class="n">lower</span><span class="p">,</span><span class="n">upper</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mf">0.9999</span><span class="p">,</span><span class="n">size_distribution_sigma</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">size_mu</span><span class="p">)</span>
        <span class="n">numberOfBins</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lower</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">upper</span><span class="p">),</span><span class="n">numberOfBins</span><span class="p">,</span><span class="n">base</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>
        <span class="c1"># The definitions used are confusing;</span>
        <span class="c1"># dp is the log of the variable</span>
        <span class="c1"># s is the standard deviation (shape function) of the log of the variate</span>
        <span class="c1"># scale is the mean of the underlying normal distribution</span>
        <span class="n">ndp</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">size_distribution_sigma</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">size_mu</span><span class="p">)</span>
    <span class="c1"># Calculate the sampling points on a fibonacci sphere</span>
    <span class="k">if</span> <span class="n">points_on_sphere</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">points_on_sphere</span> <span class="o">=</span> <span class="n">fibonacci_sphere</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span><span class="n">randomize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># Now take the average of each direction on the sphere</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points_on_sphere</span><span class="p">:</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="n">rotated_dielec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">))</span>
        <span class="n">refractive_index</span> <span class="o">=</span> <span class="n">calculate_refractive_index_scalar</span><span class="p">(</span><span class="n">rotated_dielec</span><span class="p">)</span> <span class="o">/</span> <span class="n">refractive_index_medium</span>
        <span class="c1"># print(&#39;refractive_index&#39;, refractive_index)</span>
        <span class="c1"># print(&#39;refractive_index_medium&#39;, refractive_index_medium)</span>
        <span class="c1"># print(&#39;rotated_dielec&#39;, rotated_dielec)</span>
        <span class="k">if</span> <span class="n">size_distribution_sigma</span><span class="p">:</span>
            <span class="c1"># Calculate the integral of the forward scattering factors over the distribution</span>
            <span class="n">s1_factors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">dp</span><span class="p">:</span>
                <span class="c1"># The size parameter is 2pi r / lambda</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">/</span> <span class="n">lambda_vacuum_mu</span>
                <span class="c1"># Calculate the S1 and S2 scattering factors, and store in a list</span>
                <span class="n">s1</span><span class="p">,</span><span class="n">s2</span> <span class="o">=</span> <span class="n">Mie</span><span class="o">.</span><span class="n">MieS1S2</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">refractive_index_medium</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">s1_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
            <span class="c1"># Now integrate</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">s1_factors</span><span class="o">*</span><span class="n">ndp</span><span class="p">,</span><span class="n">dp</span><span class="p">)</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">ndp</span><span class="p">,</span><span class="n">dp</span><span class="p">)</span>
            <span class="c1">#mean = np.trapz(ndp*dp,dp)</span>
            <span class="c1">#true_mean = np.exp( np.log(size_mu) + size_distribution_sigma*size_distribution_sigma/2.0)</span>
            <span class="c1">#v_cm1 = 1.0E4/lambda_vacuum_mu</span>
            <span class="c1">#print(&quot;Frequency,normal,mean&quot;,v_cm1,normal,true_mean,mean)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">normal</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0E-2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning integration of log-normal distribution in error&quot;</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stopping calculation - likely problem is too large a sigma for log-normal distribution&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate the scattering factors at 0 degrees</span>
            <span class="n">s1</span><span class="p">,</span><span class="n">s2</span> <span class="o">=</span> <span class="n">Mie</span><span class="o">.</span><span class="n">MieS1S2</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="n">refractive_index_medium</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># See van de Hulst page 129, 130</span>
        <span class="c1"># Refractive index of material is</span>
        <span class="c1"># the sign of the imaginary component has changed for compatibility with MG/Bruggeman</span>
        <span class="n">refractive_index</span> <span class="o">=</span> <span class="n">refractive_index_medium</span> <span class="o">*</span> <span class="p">(</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">N_nm</span> <span class="o">/</span> <span class="p">(</span> <span class="n">k_nm</span> <span class="o">*</span> <span class="n">k_nm</span> <span class="o">*</span> <span class="n">k_nm</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">trace</span> <span class="o">+=</span> <span class="n">refractive_index</span>
    <span class="c1"># return an isotropic tensor</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_on_sphere</span><span class="p">)</span>
    <span class="n">eff</span> <span class="o">=</span> <span class="n">trace</span> <span class="o">*</span> <span class="n">trace</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">eff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">eff</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eff</span><span class="p">]])</span>

<div class="viewcode-block" id="mie_scattering"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.mie_scattering">[docs]</a><span class="k">def</span> <span class="nf">mie_scattering</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">size_mu</span><span class="p">,</span> <span class="n">size_distribution_sigma</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective constant permittivity using a Mie scattering approach.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric_medium : array_like (3x3)</span>
<span class="sd">        Dielectric constant tensor of the medium.</span>
<span class="sd">    crystal_permittivity : array_like (3x3)</span>
<span class="sd">        Total frequency dielectric constant tensor at the current frequency.</span>
<span class="sd">    shape : str, optional</span>
<span class="sd">        The name of the current shape (NOT USED).</span>
<span class="sd">    L : array_like, optional</span>
<span class="sd">        The shape&#39;s depolarisation matrix (NOT USED).</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration.</span>
<span class="sd">    size_mu : float</span>
<span class="sd">        The particle size in microns</span>
<span class="sd">    size_distribution_sigma : float</span>
<span class="sd">        The log normal value of sigma.</span>
<span class="sd">    vf : float</span>
<span class="sd">        The volume fraction of filler.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or array_like</span>
<span class="sd">        The effective dielectric constant.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In this method, the MG method is used to calculate the averaged effective permittivity.</span>
<span class="sd">    Then, the permittivity of the isotropic sphere that would give the same average permittivity is calculated.</span>
<span class="sd">    Finally, the Mie scattering of that sphere is calculated. The routine returns the effective dielectric constant.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># Calculate the MG permittivity with no size effects</span>
    <span class="c1">#</span>
    <span class="n">mg_permittivity</span> <span class="o">=</span> <span class="n">maxwell</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="mf">0.0000001</span><span class="p">)</span>
    <span class="c1"># Use scalar quantities to calculate the dielectric constant of the equivalent isotropic sphere</span>
    <span class="n">ef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">mg_permittivity</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="n">em</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="c1"># Calculate the permittivity of an isotropic sphere that has the same effective permittivity</span>
    <span class="n">einclusion</span> <span class="o">=</span> <span class="p">(</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">vf</span><span class="o">*</span><span class="n">em</span><span class="o">*</span><span class="n">em</span> <span class="o">-</span> <span class="p">(</span><span class="n">ef</span> <span class="o">-</span> <span class="n">em</span><span class="p">)</span><span class="o">*</span><span class="n">em</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">vf</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">ef</span><span class="o">-</span><span class="n">em</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">vf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">vf</span><span class="o">*</span><span class="n">em</span><span class="p">)</span>
    <span class="c1"># define i as a complex number</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># We need to taken account of the change in wavelength and the change in size parameter due to the</span>
    <span class="c1"># None unit value of the dielectric of the embedding medium</span>
    <span class="c1"># The size parameter is 2pi r / lambda</span>
    <span class="c1"># The effective lambda in the supporting medium is lambda / sqrt(emedium)</span>
    <span class="c1"># Where the refractive index is taken to be sqrt(emedium) (non magnetic materials)</span>
    <span class="n">emedium</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="n">refractive_index_medium</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">emedium</span><span class="p">))</span>
    <span class="n">lambda_vacuum_mu</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">size_mu</span> <span class="o">/</span> <span class="n">size</span>
    <span class="n">wavelength_nm</span> <span class="o">=</span> <span class="n">lambda_vacuum_mu</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">refractive_index_medium</span>
    <span class="n">radius_nm</span> <span class="o">=</span> <span class="n">size_mu</span> <span class="o">*</span> <span class="mi">1000</span>
    <span class="c1"># The wavevector in nm-1</span>
    <span class="n">k_nm</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">wavelength_nm</span>
    <span class="c1"># volume of a particle in nm^3</span>
    <span class="n">V_nm</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">/</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius_nm</span> <span class="o">*</span> <span class="n">radius_nm</span> <span class="o">*</span> <span class="n">radius_nm</span>
    <span class="c1"># Number density of particles (number / nm^3)</span>
    <span class="n">N_nm</span> <span class="o">=</span> <span class="n">vf</span> <span class="o">/</span> <span class="n">V_nm</span>
    <span class="c1"># If there is a size distribution set up to use it</span>
    <span class="k">if</span> <span class="n">size_distribution_sigma</span><span class="p">:</span>
        <span class="n">lower</span><span class="p">,</span><span class="n">upper</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mf">0.9999</span><span class="p">,</span><span class="n">size_distribution_sigma</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">size_mu</span><span class="p">)</span>
        <span class="n">numberOfBins</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lower</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">upper</span><span class="p">),</span><span class="n">numberOfBins</span><span class="p">,</span><span class="n">base</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>
        <span class="c1"># The definitions used are confusing;</span>
        <span class="c1"># dp is the log of the variable</span>
        <span class="c1"># s is the standard deviation (shape function) of the log of the variate</span>
        <span class="c1"># scale is the mean of the underlying normal distribution</span>
        <span class="n">ndp</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">size_distribution_sigma</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">size_mu</span><span class="p">)</span>
        <span class="c1">#print(&quot;DP&quot;,dp)</span>
        <span class="c1">#print(&quot;NDP&quot;,ndp)</span>
        <span class="c1">#print(&quot;Upper lower&quot;,lower,upper)</span>
        <span class="c1">#print(&quot;Size_MU&quot;,size_mu)</span>
    <span class="n">refractive_index</span> <span class="o">=</span> <span class="n">calculate_refractive_index_scalar</span><span class="p">(</span><span class="n">einclusion</span><span class="p">)</span> <span class="o">/</span> <span class="n">refractive_index_medium</span>
    <span class="k">if</span> <span class="n">size_distribution_sigma</span><span class="p">:</span>
        <span class="c1"># Calculate the integral of the forward scattering factors over the distribution</span>
        <span class="n">s1_factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">dp</span><span class="p">:</span>
            <span class="c1"># The size parameter is 2pi r / lambda</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">/</span> <span class="n">lambda_vacuum_mu</span>
            <span class="c1"># Calculate the S1 and S2 scattering factors, and store in a list</span>
            <span class="n">s1</span><span class="p">,</span><span class="n">s2</span> <span class="o">=</span> <span class="n">Mie</span><span class="o">.</span><span class="n">MieS1S2</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">refractive_index_medium</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">s1_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
        <span class="c1"># Now integrate</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">s1_factors</span><span class="o">*</span><span class="n">ndp</span><span class="p">,</span><span class="n">dp</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">ndp</span><span class="p">,</span><span class="n">dp</span><span class="p">)</span>
        <span class="c1">#mean = np.trapz(ndp*dp,dp)</span>
        <span class="c1">#true_mean = np.exp( np.log(size_mu) + size_distribution_sigma*size_distribution_sigma/2.0)</span>
        <span class="c1">#v_cm1 = 1.0E4/lambda_vacuum_mu</span>
        <span class="c1">#print(&quot;Frequency,normal,mean&quot;,v_cm1,normal,true_mean,mean)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">normal</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0E-2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning integration of log-normal distribution in error&quot;</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stopping calculation - likely problem is too large a sigma for log-normal distribution&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Calculate the scattering factors at 0 degrees</span>
        <span class="n">s1</span><span class="p">,</span><span class="n">s2</span> <span class="o">=</span> <span class="n">Mie</span><span class="o">.</span><span class="n">MieS1S2</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="n">refractive_index_medium</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># See van de Hulst page 129, 130</span>
    <span class="c1"># Refractive index of material is</span>
    <span class="c1"># the sign of the imaginary component has changed for compatibility with MG/Bruggeman</span>
    <span class="n">refractive_index</span> <span class="o">=</span> <span class="n">refractive_index_medium</span> <span class="o">*</span> <span class="p">(</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">N_nm</span> <span class="o">/</span> <span class="p">(</span> <span class="n">k_nm</span> <span class="o">*</span> <span class="n">k_nm</span> <span class="o">*</span> <span class="n">k_nm</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">eff</span> <span class="o">=</span> <span class="n">refractive_index</span> <span class="o">*</span> <span class="n">refractive_index</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">eff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">eff</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eff</span><span class="p">]])</span></div>

<div class="viewcode-block" id="anisotropic_mie_scattering"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.anisotropic_mie_scattering">[docs]</a><span class="k">def</span> <span class="nf">anisotropic_mie_scattering</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">size_mu</span><span class="p">,</span> <span class="n">size_distribution_sigma</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective constant permittivity using a Mie scattering approach.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric_medium : array_like (3x3)</span>
<span class="sd">        The dielectric constant tensor of the medium.</span>
<span class="sd">    crystal_permittivity : array_like (3x3)</span>
<span class="sd">        The total frequency dielectric constant tensor at the current frequency.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The name of the current shape (NOT USED).</span>
<span class="sd">    L : array_like</span>
<span class="sd">        The shape&#39;s depolarisation matrix (NOT USED).</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration.</span>
<span class="sd">    size_mu : float</span>
<span class="sd">        The particle size in microns</span>
<span class="sd">    size_distribution_sigma : float</span>
<span class="sd">        The log normal value of sigma.</span>
<span class="sd">    vf : float</span>
<span class="sd">        The volume fraction of filler.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Mie only works for spherical particles, so the `shape`, and `L` parameters are ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    effective_dielectric_constant : float</span>
<span class="sd">        The effective dielectric constant.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># define i as a complex number</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># We need to taken account of the change in wavelength and the change in size parameter due to the</span>
    <span class="c1"># None unit value of the dielectric of the embedding medium</span>
    <span class="c1"># The size parameter is 2pi r / lambda</span>
    <span class="c1"># The effective lambda in the supporting medium is lambda / sqrt(emedium)</span>
    <span class="c1"># Where the refractive index is taken to be sqrt(emedium) (non magnetic materials)</span>
    <span class="n">emedium</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="n">refractive_index_medium</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">emedium</span><span class="p">))</span>
    <span class="n">lambda_vacuum_mu</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">size_mu</span> <span class="o">/</span> <span class="n">size</span>
    <span class="n">wavelength_nm</span> <span class="o">=</span> <span class="n">lambda_vacuum_mu</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">refractive_index_medium</span>
    <span class="n">radius_nm</span> <span class="o">=</span> <span class="n">size_mu</span> <span class="o">*</span> <span class="mi">1000</span>
    <span class="c1"># To account for anisotropy we diagonalise the real part of the dielectric matrix and transform</span>
    <span class="c1"># the full matrix with the eigenvectors, U</span>
    <span class="c1"># Find U and E, such that UT. D. U = E (where D is the real part of crystal_permittivity)</span>
    <span class="n">E</span><span class="p">,</span><span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">crystal_permittivity</span><span class="p">))</span>
    <span class="c1"># Transform the full dielectric matrix</span>
    <span class="n">rotated_dielec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">crystal_permittivity</span><span class="p">,</span><span class="n">U</span><span class="p">))</span>
    <span class="c1"># The wavevector in nm-1</span>
    <span class="n">k_nm</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">wavelength_nm</span>
    <span class="c1"># volume of a particle in nm^3</span>
    <span class="n">V_nm</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">/</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius_nm</span> <span class="o">*</span> <span class="n">radius_nm</span> <span class="o">*</span> <span class="n">radius_nm</span>
    <span class="c1"># Number density of particles (number / nm^3)</span>
    <span class="n">N_nm</span> <span class="o">=</span> <span class="n">vf</span> <span class="o">/</span> <span class="n">V_nm</span>
    <span class="c1"># If there is a size distribution set up to use it</span>
    <span class="k">if</span> <span class="n">size_distribution_sigma</span><span class="p">:</span>
        <span class="n">lower</span><span class="p">,</span><span class="n">upper</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mf">0.9999</span><span class="p">,</span><span class="n">size_distribution_sigma</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">size_mu</span><span class="p">)</span>
        <span class="n">numberOfBins</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lower</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">upper</span><span class="p">),</span><span class="n">numberOfBins</span><span class="p">,</span><span class="n">base</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>
        <span class="c1"># The definitions used are confusing;</span>
        <span class="c1"># dp is the log of the variable</span>
        <span class="c1"># s is the standard deviation (shape function) of the log of the variate</span>
        <span class="c1"># scale is the mean of the underlying normal distribution</span>
        <span class="n">ndp</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">size_distribution_sigma</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">size_mu</span><span class="p">)</span>
        <span class="c1">#print(&quot;DP&quot;,dp)</span>
        <span class="c1">#print(&quot;NDP&quot;,ndp)</span>
        <span class="c1">#print(&quot;Upper lower&quot;,lower,upper)</span>
        <span class="c1">#print(&quot;Size_MU&quot;,size_mu)</span>
    <span class="c1"># We are now going to ignore any off-diagonal elements</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># Now take the average of each direction</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">refractive_index</span> <span class="o">=</span> <span class="n">calculate_refractive_index_scalar</span><span class="p">(</span><span class="n">rotated_dielec</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="n">index</span><span class="p">])</span> <span class="o">/</span> <span class="n">refractive_index_medium</span>
        <span class="k">if</span> <span class="n">size_distribution_sigma</span><span class="p">:</span>
            <span class="c1"># Calculate the integral of the forward scattering factors over the distribution</span>
            <span class="n">s1_factors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">dp</span><span class="p">:</span>
                <span class="c1"># The size parameter is 2pi r / lambda</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">/</span> <span class="n">lambda_vacuum_mu</span>
                <span class="c1"># Calculate the S1 and S2 scattering factors, and store in a list</span>
                <span class="n">s1</span><span class="p">,</span><span class="n">s2</span> <span class="o">=</span> <span class="n">Mie</span><span class="o">.</span><span class="n">MieS1S2</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">refractive_index_medium</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">s1_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
            <span class="c1"># Now integrate</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">s1_factors</span><span class="o">*</span><span class="n">ndp</span><span class="p">,</span><span class="n">dp</span><span class="p">)</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">ndp</span><span class="p">,</span><span class="n">dp</span><span class="p">)</span>
            <span class="c1">#mean = np.trapz(ndp*dp,dp)</span>
            <span class="c1">#true_mean = np.exp( np.log(size_mu) + size_distribution_sigma*size_distribution_sigma/2.0)</span>
            <span class="c1">#v_cm1 = 1.0E4/lambda_vacuum_mu</span>
            <span class="c1">#print(&quot;Frequency,normal,mean&quot;,v_cm1,normal,true_mean,mean)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">normal</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0E-2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning integration of log-normal distribution in error&quot;</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stopping calculation - likely problem is too large a sigma for log-normal distribution&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate the scattering factors at 0 degrees</span>
            <span class="n">s1</span><span class="p">,</span><span class="n">s2</span> <span class="o">=</span> <span class="n">Mie</span><span class="o">.</span><span class="n">MieS1S2</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="n">refractive_index_medium</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># See van de Hulst page 129, 130</span>
        <span class="c1"># Refractive index of material is</span>
        <span class="c1"># the sign of the imaginary component has changed for compatibility with MG/Bruggeman</span>
        <span class="n">refractive_index</span> <span class="o">=</span> <span class="n">refractive_index_medium</span> <span class="o">*</span> <span class="p">(</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">N_nm</span> <span class="o">/</span> <span class="p">(</span> <span class="n">k_nm</span> <span class="o">*</span> <span class="n">k_nm</span> <span class="o">*</span> <span class="n">k_nm</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">trace</span> <span class="o">+=</span> <span class="n">refractive_index</span>
    <span class="c1"># return an isotropic tensor</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="n">eff</span> <span class="o">=</span> <span class="n">trace</span> <span class="o">*</span> <span class="n">trace</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">eff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">eff</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eff</span><span class="p">]])</span></div>

<div class="viewcode-block" id="maxwell"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.maxwell">[docs]</a><span class="k">def</span> <span class="nf">maxwell</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective constant permittivity using the Maxwell Garnett method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric_medium : tensor (3x3)</span>
<span class="sd">        The dielectric constant tensor of the medium.</span>
<span class="sd">    crystal_permittivity : tensor (3x3)</span>
<span class="sd">        The total frequency dielectric constant tensor at the current frequency.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The name of the current shape.</span>
<span class="sd">    L : matrix (3x3)</span>
<span class="sd">        The shape&#39;s depolarisation matrix.</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration.</span>
<span class="sd">    vf : float</span>
<span class="sd">        The volume fraction of filler.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor (3x3)</span>
<span class="sd">        The effective dielectric constant.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">initialise_unit_tensor</span><span class="p">()</span>
    <span class="n">emedium</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="c1"># If appropriate calculate a size effect using Equations 10.38 and 10.39 in Sihvola</span>
    <span class="n">size_factor</span> <span class="o">=</span> <span class="n">calculate_size_factor</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="c1"># Equation 5.78 in Sihvola</span>
    <span class="n">nalpha</span> <span class="o">=</span> <span class="n">emedium</span><span class="o">*</span><span class="n">vf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">crystal_permittivity</span> <span class="o">-</span> <span class="n">dielectric_medium</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">dielectric_medium</span> <span class="o">+</span> <span class="n">size_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">crystal_permittivity</span><span class="o">-</span><span class="n">dielectric_medium</span><span class="p">))))</span>
    <span class="n">nalphal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">nalpha</span><span class="o">/</span><span class="n">emedium</span><span class="p">),</span> <span class="n">L</span><span class="p">)</span>
    <span class="c1"># average the polarisability over orientation</span>
    <span class="n">nalpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">nalpha</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">unit</span>
    <span class="c1"># average the polarisability*L over orientation</span>
    <span class="n">nalphal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">nalphal</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">unit</span>
    <span class="n">polarisation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">unit</span> <span class="o">-</span> <span class="n">nalphal</span><span class="p">),</span> <span class="n">nalpha</span><span class="p">)</span>
    <span class="n">effd</span>         <span class="o">=</span> <span class="n">dielectric_medium</span> <span class="o">+</span> <span class="n">polarisation</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">effd</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">]])</span></div>

<div class="viewcode-block" id="maxwell_sihvola"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.maxwell_sihvola">[docs]</a><span class="k">def</span> <span class="nf">maxwell_sihvola</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective constant permittivity using the Maxwell Garnett method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric_medium : tensor (3x3)</span>
<span class="sd">        The dielectric constant tensor of the medium.</span>
<span class="sd">    crystal_permittivity : tensor (3x3)</span>
<span class="sd">        The total frequency dielectric constant tensor at the current frequency.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The name of the current shape.</span>
<span class="sd">    L : matrix (3x3)</span>
<span class="sd">        The shape&#39;s depolarisation matrix.</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration.</span>
<span class="sd">    vf : float</span>
<span class="sd">        The volume fraction of filler.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor</span>
<span class="sd">        The effective dielectric constant.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">initialise_unit_tensor</span><span class="p">()</span>
    <span class="c1"># Equation 6.29 on page 123 of Sihvola</span>
    <span class="c1"># Equation 6.40 gives the averaging over the orientation function</span>
    <span class="c1"># See also equation 5.80 on page 102 and equation 4.31 on page 70</span>
    <span class="n">Me</span> <span class="o">=</span> <span class="n">dielectric_medium</span>
    <span class="c1"># assume that the medium is isotropic calculate the inverse of the dielectric</span>
    <span class="n">Mem1</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">Me</span><span class="p">)</span>
    <span class="n">Mi</span> <span class="o">=</span> <span class="n">crystal_permittivity</span>
    <span class="c1"># If appropriate calculate a size effect using Equations 10.38 and 10.39 in Sihvola</span>
    <span class="n">size_factor</span> <span class="o">=</span> <span class="n">calculate_size_factor</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="c1"># calculate the polarisability matrix x the number density of inclusions</span>
    <span class="n">nA</span> <span class="o">=</span> <span class="n">vf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">Mi</span><span class="o">-</span><span class="n">Me</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">unit</span> <span class="o">+</span> <span class="p">(</span><span class="n">size_factor</span> <span class="o">*</span> <span class="n">Mem1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">Mi</span> <span class="o">-</span> <span class="n">Me</span><span class="p">)))))</span>
    <span class="n">nAL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">nA</span><span class="p">),</span> <span class="n">L</span><span class="p">)</span>
    <span class="c1"># average the polarisability over orientation</span>
    <span class="n">nA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">nA</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">unit</span>
    <span class="c1"># average the polarisability*L over orientation</span>
    <span class="n">nAL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">nAL</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">Mem1</span> <span class="o">*</span> <span class="n">unit</span>
    <span class="c1"># Calculate the average polarisation factor which scales the average field</span>
    <span class="c1"># based on equation 5.80</span>
    <span class="c1"># &lt;P&gt; = pol . &lt;E&gt;</span>
    <span class="n">pol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">unit</span> <span class="o">-</span> <span class="n">nAL</span><span class="p">),</span> <span class="n">nA</span><span class="p">)</span>
    <span class="c1"># Meff . &lt;E&gt; = Me . &lt;E&gt; + &lt;P&gt;</span>
    <span class="c1"># Meff . &lt;E&gt; = Me. &lt;E&gt; + pol . &lt;E&gt;</span>
    <span class="c1"># Meff = Me + pol</span>
    <span class="n">effd</span>         <span class="o">=</span> <span class="n">dielectric_medium</span> <span class="o">+</span> <span class="n">pol</span>
    <span class="c1"># Average over orientation</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">effd</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">]])</span></div>

<div class="viewcode-block" id="coherent"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.coherent">[docs]</a><span class="k">def</span> <span class="nf">coherent</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dielectric_apparent</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective constant permittivity using the Coherent method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric_medium : tensor (3x3)</span>
<span class="sd">        The dielectric constant tensor of the medium.</span>
<span class="sd">    crystal_permittivity : tensor (3x3)</span>
<span class="sd">        The total frequency dielectric constant tensor at the current frequency.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The name of the current shape.</span>
<span class="sd">    L : matrix (3x3)</span>
<span class="sd">        The shape&#39;s depolarisation matrix.</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration.</span>
<span class="sd">    vf : float</span>
<span class="sd">        The volume fraction of filler.</span>
<span class="sd">    dielectric_apparent : 3x3 array of floats</span>
<span class="sd">        The current estimate of the dielectric</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor</span>
<span class="sd">        The effective dielectric constant.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">dielectric_apparent</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">dielectric_apparent</span> <span class="o">+</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="n">coherent2</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">dielectric_apparent</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dielectric_apparent</span></div>

<span class="k">def</span> <span class="nf">coherent2</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">dielectric_apparent</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective constant permittivity using the Coherent2 method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric_medium : tensor (3x3)</span>
<span class="sd">        The dielectric constant tensor of the medium.</span>
<span class="sd">    dielectric_apparent : 3x3 array of floats</span>
<span class="sd">        The current estimate of the dielectric</span>
<span class="sd">    crystal_permittivity : tensor (3x3)</span>
<span class="sd">        The total frequency dielectric constant tensor at the current frequency.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The name of the current shape.</span>
<span class="sd">    L : matrix (3x3)</span>
<span class="sd">        The shape&#39;s depolarisation matrix.</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration.</span>
<span class="sd">    vf : float</span>
<span class="sd">        The volume fraction of filler.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor (3x3)</span>
<span class="sd">        The effective dielectric constant.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">initialise_unit_tensor</span><span class="p">()</span>
    <span class="n">emedium</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="n">eapparent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">dielectric_apparent</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="c1"># If appropriate calculate a size effect using Equations 10.38 and 10.39 in Sihvola</span>
    <span class="n">size_factor</span> <span class="o">=</span> <span class="n">calculate_size_factor</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="c1"># Equation 5.78 in Sihvola</span>
    <span class="n">nalpha</span> <span class="o">=</span> <span class="n">emedium</span><span class="o">*</span><span class="n">vf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">crystal_permittivity</span> <span class="o">-</span> <span class="n">dielectric_medium</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">dielectric_medium</span> <span class="o">+</span> <span class="n">size_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">crystal_permittivity</span><span class="o">-</span><span class="n">dielectric_medium</span><span class="p">))))</span>
    <span class="n">nalphal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">nalpha</span><span class="o">/</span><span class="n">eapparent</span><span class="p">),</span> <span class="n">L</span><span class="p">)</span>
    <span class="c1"># average the polarisability over orientation</span>
    <span class="n">nalpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">nalpha</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">unit</span>
    <span class="c1"># average the polarisability*L over orientation</span>
    <span class="n">nalphal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">nalphal</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">unit</span>
    <span class="n">polarisation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">unit</span> <span class="o">-</span> <span class="n">nalphal</span><span class="p">),</span> <span class="n">nalpha</span><span class="p">)</span>
    <span class="n">effd</span>         <span class="o">=</span> <span class="n">dielectric_medium</span> <span class="o">+</span> <span class="n">polarisation</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">effd</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">]])</span>

<div class="viewcode-block" id="bruggeman_minimise"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.bruggeman_minimise">[docs]</a><span class="k">def</span> <span class="nf">bruggeman_minimise</span><span class="p">(</span> <span class="n">eps1</span><span class="p">,</span> <span class="n">eps2</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">epsbr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective constant permittivity using the method of Bruggeman (minimisation).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    eps1 : array_like (3x3)</span>
<span class="sd">        The dielectric constant tensor of medium 1.</span>
<span class="sd">    eps2 : array_like (3x3)</span>
<span class="sd">        The dielectric constant tensor of medium 2.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The name of the current shape.</span>
<span class="sd">    L : array_like (3x3)</span>
<span class="sd">        The shape&#39;s depolarisation matrix.</span>
<span class="sd">    f2 : float</span>
<span class="sd">        The volume fraction of component 2.</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration.</span>
<span class="sd">    epsbr : float (3x3)</span>
<span class="sd">        An initial guess at the solution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor (3x3)</span>
<span class="sd">        The effective dielectric constant.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function applies homogenization formalisms to active dielectric composite materials as discussed in the work of Tom G. Mackay and Akhlesh Lakhtakia.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">f2</span>
    <span class="c1"># we need to fool the optimiser into thinking that it has two real variables</span>
    <span class="c1"># in fact the second is imaginary and reconstructed in the _brug_minimise routine</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">epsbr</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">trace</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">trace</span><span class="p">)))])</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;xtol&quot;</span><span class="p">:</span> <span class="mf">1.0e-4</span><span class="p">,</span>
               <span class="s2">&quot;ftol&quot;</span><span class="p">:</span> <span class="mf">1.0E-4</span><span class="p">}</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">_brug_minimise_tensor</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Powell&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">eps1</span><span class="p">,</span> <span class="n">eps2</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A Bruggeman solution was not found at this frequency&quot;</span><span class="p">)</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">x</span>
    <span class="c1"># transform the imaginary variable back</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">]])</span></div>

<div class="viewcode-block" id="bruggeman_iter"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.bruggeman_iter">[docs]</a><span class="k">def</span> <span class="nf">bruggeman_iter</span><span class="p">(</span> <span class="n">eps1</span><span class="p">,</span> <span class="n">eps2</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">epsbr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate an iteration of the Bruggeman method..</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    eps1 : array_like (3x3)</span>
<span class="sd">        The dielectric constant tensor of medium 1.</span>
<span class="sd">    eps2 : array_like (3x3)</span>
<span class="sd">        The dielectric constant tensor of medium 2.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The name of the current shape.</span>
<span class="sd">    L : array_like (3x3)</span>
<span class="sd">        The shape&#39;s depolarisation matrix.</span>
<span class="sd">    f2 : float</span>
<span class="sd">        The volume fraction of component 2.</span>
<span class="sd">    size : float</span>
<span class="sd">        The dimensionless size parameter for the frequency under consideration.</span>
<span class="sd">    epsbr : float (3x3)</span>
<span class="sd">        An initial guess at the solution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor (3x3)</span>
<span class="sd">        The effective dielectric constant.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function applies homogenization formalisms to active dielectric composite materials as discussed in the work of Tom G. Mackay and Akhlesh Lakhtakia.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">f2</span>
    <span class="c1"># perform an iteration</span>
    <span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">niters</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">converged</span><span class="p">:</span>
        <span class="n">niters</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">epsbr</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="n">_brug_iter_error</span><span class="p">(</span><span class="n">epsbr</span><span class="p">,</span> <span class="n">eps1</span><span class="p">,</span> <span class="n">eps2</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0E-8</span><span class="p">:</span>
            <span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">niters</span> <span class="o">&gt;</span> <span class="mi">3000</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bruggeman iterations failed, error=&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
            <span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">average_tensor</span><span class="p">(</span><span class="n">epsbr</span><span class="p">)</span></div>

<div class="viewcode-block" id="average_tensor"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.average_tensor">[docs]</a><span class="k">def</span> <span class="nf">average_tensor</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the averaged tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : tensor (3x3)</span>
<span class="sd">        The tensor</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : tensor</span>
<span class="sd">        The averaged tensor.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">]])</span></div>

<div class="viewcode-block" id="_brug_minimise_scalar"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator._brug_minimise_scalar">[docs]</a><span class="k">def</span> <span class="nf">_brug_minimise_scalar</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">eps1</span><span class="p">,</span> <span class="n">eps2</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bruggeman method using scalar quantities (suitable for powell minimisation method).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    variables : list of 2 floats</span>
<span class="sd">        The real and imaginary components of the scalar permittivity</span>
<span class="sd">    eps1      : tensor (3x3)</span>
<span class="sd">        Permittivity of phase 1</span>
<span class="sd">    eps2      : tensor (3x3)</span>
<span class="sd">        Permittivity of phase 2</span>
<span class="sd">    shape      : string</span>
<span class="sd">        The particle shape</span>
<span class="sd">    L         : 3x3 tensor</span>
<span class="sd">        Depolarisation tensor</span>
<span class="sd">    f1        : float</span>
<span class="sd">        The volume fraction of phase 1</span>
<span class="sd">    size      : float</span>
<span class="sd">        The size of the particle</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float : The error associated with the current values of the permittivities</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># unpack the complex number from the variables</span>
    <span class="c1"># two things going on here.</span>
    <span class="c1"># 1. the two variables refer to the real and imaginary components</span>
    <span class="c1"># 2. we require the imaginary component to be positive</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">epsbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">]])</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">f1</span>
    <span class="c1"># If appropriate calculate a size effect using Equations 10.38 and 10.39 in Sihvola</span>
    <span class="n">size_factor</span> <span class="o">=</span> <span class="n">calculate_size_factor</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">eps1</span> <span class="o">-</span> <span class="n">epsbr</span><span class="p">))</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">size_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">eps2</span> <span class="o">-</span> <span class="n">epsbr</span><span class="p">))</span>
    <span class="n">tb1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
    <span class="n">tb2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
    <span class="n">ta1</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">tb1</span><span class="p">)</span>
    <span class="n">ta2</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">tb2</span><span class="p">)</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">eps1</span><span class="o">-</span><span class="n">epsbr</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">eps2</span><span class="o">-</span><span class="n">epsbr</span>
    <span class="n">tc1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
    <span class="n">tc2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
    <span class="c1"># alpha1 and 2 are the polarisabilities of 1 and 2 in the effective medium</span>
    <span class="n">talpha1</span> <span class="o">=</span> <span class="n">tc1</span> <span class="o">*</span> <span class="n">ta1</span>
    <span class="n">talpha2</span> <span class="o">=</span> <span class="n">tc2</span> <span class="o">*</span> <span class="n">ta2</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">f1</span><span class="o">*</span><span class="n">talpha1</span> <span class="o">+</span> <span class="n">f2</span><span class="o">*</span><span class="n">talpha2</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>
    <span class="c1"># Nasty issue in the powell method, the convergence on tol is given</span>
    <span class="c1"># relative to the solution (0.0).  Only a small number is added.</span>
    <span class="c1"># So we shift the solution by 1.0, the tol is now relative to 1.0</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="o">+</span><span class="n">error</span></div>

<div class="viewcode-block" id="_brug_minimise_tensor"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator._brug_minimise_tensor">[docs]</a><span class="k">def</span> <span class="nf">_brug_minimise_tensor</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">eps1</span><span class="p">,</span> <span class="n">eps2</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bruggeman method using tensor quantities.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    variables : list of 2 floats</span>
<span class="sd">        The real and imaginary components of the scalar permittivity</span>
<span class="sd">    eps1      : tensor (3x3)</span>
<span class="sd">        Permittivity of phase 1</span>
<span class="sd">    eps2      : tensor (3x3)</span>
<span class="sd">        Permittivity of phase 2</span>
<span class="sd">    shape      : string</span>
<span class="sd">        The particle shape</span>
<span class="sd">    L         : 3x3 tensor</span>
<span class="sd">        Depolarisation tensor</span>
<span class="sd">    f1        : float</span>
<span class="sd">        The volume fraction of phase 1</span>
<span class="sd">    size      : float</span>
<span class="sd">        The size of the particle</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float : The error associated with the current values of the permittivities</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># unpack the complex number from the variables</span>
    <span class="c1"># two things going on here.</span>
    <span class="c1"># 1. the two variables refer to the real and imaginary components</span>
    <span class="c1"># 2. we require the imaginary component to be positive</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">epsbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">trace</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">]])</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">f1</span>
    <span class="c1"># If appropriate calculate a size effect using Equations 10.38 and 10.39 in Sihvola</span>
    <span class="n">size_factor</span> <span class="o">=</span> <span class="n">calculate_size_factor</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">eps1</span> <span class="o">-</span> <span class="n">epsbr</span><span class="p">))</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">size_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">eps2</span> <span class="o">-</span> <span class="n">epsbr</span><span class="p">))</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">average_tensor</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">average_tensor</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">epsbr</span> <span class="o">+</span> <span class="n">b1</span><span class="p">)</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">epsbr</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">eps1</span><span class="o">-</span><span class="n">epsbr</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">eps2</span><span class="o">-</span><span class="n">epsbr</span>
    <span class="c1"># c1 = average_tensor(eps1-epsbr)</span>
    <span class="c1"># c2 = average_tensor(eps2-epsbr)</span>
    <span class="n">alpha1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
    <span class="n">alpha2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
    <span class="n">alpha1</span> <span class="o">=</span> <span class="n">average_tensor</span><span class="p">(</span><span class="n">alpha1</span><span class="p">)</span>
    <span class="n">alpha2</span> <span class="o">=</span> <span class="n">average_tensor</span><span class="p">(</span><span class="n">alpha2</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">f1</span><span class="o">*</span><span class="n">alpha1</span> <span class="o">+</span> <span class="n">f2</span><span class="o">*</span><span class="n">alpha2</span>
    <span class="n">fr</span>  <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">fi</span>  <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">fr</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">fi</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
    <span class="c1"># Nasty issue in the powell method, the convergence on tol is given</span>
    <span class="c1"># relative to the solution (0.0).  Only a small number is added.</span>
    <span class="c1"># So we shift the solution by 1.0, the tol is now relative to 1.0</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="o">+</span><span class="n">error</span></div>

<div class="viewcode-block" id="_brug_iter_error"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator._brug_iter_error">[docs]</a><span class="k">def</span> <span class="nf">_brug_iter_error</span><span class="p">(</span><span class="n">epsbr</span><span class="p">,</span> <span class="n">eps1</span><span class="p">,</span> <span class="n">eps2</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Routine to calculate the error in the Bruggeman method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epsbr : list of 2 floats</span>
<span class="sd">        The real and imaginary components of the scalar permittivity</span>
<span class="sd">    eps1      : tensor (3x3)</span>
<span class="sd">        Permittivity of phase 1</span>
<span class="sd">    eps2      : tensor (3x3)</span>
<span class="sd">        Permittivity of phase 2</span>
<span class="sd">    shape : string</span>
<span class="sd">        The shape descriptor</span>
<span class="sd">    L         : 3x3 tensor</span>
<span class="sd">        Depolarisation tensor</span>
<span class="sd">    f1        : float</span>
<span class="sd">        The volume fraction of phase 1</span>
<span class="sd">    size      : float</span>
<span class="sd">        The size of the particle</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float : The error associated with the current values of the permittivities</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">f1</span>
    <span class="c1"># If appropriate calculate a size effect using Equations 10.38 and 10.39 in Sihvola</span>
    <span class="n">size_factor</span> <span class="o">=</span> <span class="n">calculate_size_factor</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="n">leps1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">eps1</span> <span class="o">-</span> <span class="n">epsbr</span><span class="p">))</span>
    <span class="n">leps2</span> <span class="o">=</span> <span class="n">size_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">eps2</span> <span class="o">-</span> <span class="n">epsbr</span><span class="p">))</span>
    <span class="n">leps1</span> <span class="o">=</span> <span class="n">average_tensor</span><span class="p">(</span><span class="n">leps1</span><span class="p">)</span>
    <span class="n">leps2</span> <span class="o">=</span> <span class="n">average_tensor</span><span class="p">(</span><span class="n">leps2</span><span class="p">)</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">epsbr</span> <span class="o">+</span> <span class="n">leps1</span><span class="p">)</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">epsbr</span> <span class="o">+</span> <span class="n">leps2</span><span class="p">)</span>
    <span class="c1"># alpha1 and 2 are the polarisabilities of 1 and 2 in the effective medium</span>
    <span class="n">eps1av</span> <span class="o">=</span> <span class="n">average_tensor</span><span class="p">(</span><span class="n">eps1</span><span class="p">)</span>
    <span class="n">eps2av</span> <span class="o">=</span> <span class="n">average_tensor</span><span class="p">(</span><span class="n">eps2</span><span class="p">)</span>
    <span class="n">alpha1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">eps1av</span><span class="o">-</span><span class="n">epsbr</span><span class="p">),</span> <span class="n">a1</span><span class="p">)</span>
    <span class="n">alpha2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">eps2av</span><span class="o">-</span><span class="n">epsbr</span><span class="p">),</span> <span class="n">a2</span><span class="p">)</span>
    <span class="c1"># the error or residual matrix should be zero for a bruggeman solution</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">f1</span><span class="o">*</span><span class="n">alpha1</span> <span class="o">+</span> <span class="n">f2</span><span class="o">*</span><span class="n">alpha2</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eps1</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span><span class="o">+</span><span class="n">f2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eps2</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">f1</span><span class="o">*</span><span class="n">a1</span> <span class="o">+</span> <span class="n">f2</span><span class="o">*</span><span class="n">a2</span><span class="p">)</span>
    <span class="n">damp</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">epsbr</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">damp</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span> <span class="o">+</span> <span class="n">damp</span><span class="o">*</span><span class="n">epsbr</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">epsbr</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="n">epsbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">epsbr</span><span class="p">,</span> <span class="n">error</span></div>

<div class="viewcode-block" id="calculate_permittivity"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.calculate_permittivity">[docs]</a><span class="k">def</span> <span class="nf">calculate_permittivity</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the permittivity from the refractive index.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    refractive_index : complex</span>
<span class="sd">        The refractive index from which the permittivity is calculated.</span>
<span class="sd">    debug : boolean</span>
<span class="sd">        True for debugging information</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    complex</span>
<span class="sd">        The calculated permittivity.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">refractive_index</span><span class="o">*</span><span class="n">refractive_index</span></div>

<div class="viewcode-block" id="calculate_refractive_index"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.calculate_refractive_index">[docs]</a><span class="k">def</span> <span class="nf">calculate_refractive_index</span><span class="p">(</span><span class="n">dielectric</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the refractive index from the dielectric constant.</span>

<span class="sd">    Calculate the trace of the dielectric and calculate both square roots.</span>
<span class="sd">    Then choose the root with the largest imaginary component. This obeys the Kramers-Konig requirements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric : complex</span>
<span class="sd">        The permittivity</span>
<span class="sd">    debug : boolean</span>
<span class="sd">        True for debugging information</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    complex</span>
<span class="sd">        The refractive index calculated from the dielectric constant.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The calculation of the refractive index from the dielectric constant involves</span>
<span class="sd">    the trace of the dielectric tensor and the selection of the square root with</span>
<span class="sd">    the largest imaginary component.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">dielectric</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
    <span class="k">return</span> <span class="n">calculate_refractive_index_scalar</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">debug</span><span class="p">)</span></div>

<div class="viewcode-block" id="calculate_refractive_index_scalar"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.calculate_refractive_index_scalar">[docs]</a><span class="k">def</span> <span class="nf">calculate_refractive_index_scalar</span><span class="p">(</span><span class="n">dielectric_scalar</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the refractive index from the dielectric constant.</span>

<span class="sd">    Calculate the trace of the dielectric and calculate both square roots.</span>
<span class="sd">    Then choose the root with the largest imaginary component. This obeys the Konig-Kramer requirements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dielectric_scalar : complex</span>
<span class="sd">        The permittivity</span>
<span class="sd">    debug : boolean</span>
<span class="sd">        True for debugging information</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    complex</span>
<span class="sd">        The refractive index calculated from the dielectric constant.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The calculation of the refractive index from the dielectric constant involves</span>
<span class="sd">    the trace of the dielectric tensor and the selection of the square root with</span>
<span class="sd">    the largest imaginary component to satisfy the Konig-Kramer conditions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solution1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dielectric_scalar</span><span class="p">)</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">cmath</span><span class="o">.</span><span class="n">polar</span><span class="p">(</span><span class="n">solution1</span><span class="p">)</span>
    <span class="n">solution2</span> <span class="o">=</span> <span class="n">cmath</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">phase</span><span class="p">)</span>
    <span class="n">real1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">solution1</span><span class="p">)</span>
    <span class="n">real2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">solution2</span><span class="p">)</span>
    <span class="n">imag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">solution1</span><span class="p">)</span>
    <span class="n">imag2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">solution2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">imag1</span><span class="p">)</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">imag2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0e-18</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">solution1</span> <span class="k">if</span> <span class="n">imag1</span> <span class="o">&gt;</span> <span class="n">imag2</span> <span class="k">else</span> <span class="n">solution2</span>
    <span class="k">elif</span> <span class="n">real1</span> <span class="o">&gt;</span> <span class="n">real2</span><span class="p">:</span>
       <span class="n">solution</span> <span class="o">=</span> <span class="n">solution1</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="n">solution</span> <span class="o">=</span> <span class="n">solution2</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">solution</span><span class="o">*</span><span class="n">solution</span><span class="o">-</span><span class="n">dielectric_scalar</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dielectric_scalar</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1.0E-8</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There is an error in refractive index&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dielectric = &quot;</span><span class="p">,</span> <span class="n">dielectric_scalar</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;solution*solution = &quot;</span><span class="p">,</span> <span class="n">solution</span><span class="o">*</span><span class="n">solution</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">solution</span><span class="o">*</span><span class="n">solution</span><span class="o">-</span><span class="n">dielectric_scalar</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;solution    = &quot;</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">solution</span><span class="o">*</span><span class="n">solution</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;solution1   = &quot;</span><span class="p">,</span> <span class="n">solution1</span><span class="p">,</span> <span class="n">solution1</span><span class="o">*</span><span class="n">solution1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;solution2   = &quot;</span><span class="p">,</span> <span class="n">solution2</span><span class="p">,</span> <span class="n">solution2</span><span class="o">*</span><span class="n">solution2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">solution</span></div>

<div class="viewcode-block" id="direction_from_shape"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.direction_from_shape">[docs]</a><span class="k">def</span> <span class="nf">direction_from_shape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine the unique direction of the shape from the shape data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list of strings</span>
<span class="sd">        Data may contain a miller indices which defines a surface, e.g., (1,1,-1), </span>
<span class="sd">        or a direction as a miller direction vector, e.g., [1,0,-1].</span>
<span class="sd">    reader : a reader objecy</span>
<span class="sd">        The reader is used to get the unit-cell</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : vector (3)</span>
<span class="sd">        Description of the unique direction determined from the data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">surface</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># original = data</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
    <span class="n">commas</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">commas</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;{&quot;</span><span class="p">:</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;{&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span><span class="p">:</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error encountered in interpretting the miller surface / vector&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">commas</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="n">hkl</span> <span class="o">=</span> <span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">()])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">hkl</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">hkl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># end of handling no commas</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hkl</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error encountered in interpretting the miller surface / vector&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">get_unit_cell</span><span class="p">()</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">convert_hkl_to_xyz</span><span class="p">(</span><span class="n">hkl</span><span class="p">)</span> <span class="k">if</span> <span class="n">surface</span> <span class="k">else</span> <span class="n">cell</span><span class="o">.</span><span class="n">convert_abc_to_xyz</span><span class="p">(</span><span class="n">hkl</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">direction</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span></div>

<div class="viewcode-block" id="solve_effective_medium_equations"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.solve_effective_medium_equations">[docs]</a><span class="k">def</span> <span class="nf">solve_effective_medium_equations</span><span class="p">(</span> 
        <span class="n">method</span>                     <span class="p">,</span>
        <span class="n">vf</span>                         <span class="p">,</span>
        <span class="n">size_mu</span>                    <span class="p">,</span>
        <span class="n">size_distribution_sigma</span>    <span class="p">,</span>
        <span class="n">matrixPermittivityFunction</span> <span class="p">,</span>
        <span class="n">shape</span>                      <span class="p">,</span>
        <span class="n">L</span>                          <span class="p">,</span>
        <span class="n">concentration</span>              <span class="p">,</span>
        <span class="n">atrPermittivity</span>            <span class="p">,</span>
        <span class="n">atrTheta</span>                   <span class="p">,</span>
        <span class="n">atrSPol</span>                    <span class="p">,</span>
        <span class="n">bubble_vf</span>                  <span class="p">,</span>
        <span class="n">bubble_radius</span>              <span class="p">,</span>
        <span class="n">previous_solution_shared</span>   <span class="p">,</span>
        <span class="n">atuple</span>                     <span class="p">,</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solve the effective medium equations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    method : str</span>
<span class="sd">        The method to be used, options include bruggeman, balan, maxwell, maxwell-garnet, averagedpermittivity, maxwell-sihvola, coherent, bruggeman-minimise, mie, anisotropic-mie.</span>
<span class="sd">    vf : float</span>
<span class="sd">        The volume fraction of dielectric.</span>
<span class="sd">    size_mu : float</span>
<span class="sd">        The particle size in micron</span>
<span class="sd">    size_distribution_sigma : float</span>
<span class="sd">        The width of the size distribution.</span>
<span class="sd">    matrixPermittivityFunction : function</span>
<span class="sd">        Function returning the matrix permittivity at a frequency.</span>
<span class="sd">    shape : str</span>
<span class="sd">        The shape of the particles.</span>
<span class="sd">    L : array</span>
<span class="sd">        The depolarisation matrix.</span>
<span class="sd">    concentration : float</span>
<span class="sd">        The concentration of particles.</span>
<span class="sd">    atrPermittivity : float</span>
<span class="sd">        The permittivity of the ATR substrate.</span>
<span class="sd">    atrTheta : float</span>
<span class="sd">        The ATR angle of incidence.</span>
<span class="sd">    atrSPol : str</span>
<span class="sd">        The ATR polarisation.</span>
<span class="sd">    bubble_vf : float</span>
<span class="sd">        Volume fraction of bubbles.</span>
<span class="sd">    bubble_radius : float</span>
<span class="sd">        The radius of bubbles.</span>
<span class="sd">    previous_solution_shared : bool</span>
<span class="sd">        Use the previous solution to speed up iterations in the case of Bruggeman and coherent methods.</span>
<span class="sd">    atuple : tuple</span>
<span class="sd">        A tuple containing frequency in cm-1 (v_cm1) and a rank 3 tensor of the permittivity of the crystal at a given frequency (crystalPermittivity).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple of results</span>
<span class="sd">        v_cm1</span>
<span class="sd">        method</span>
<span class="sd">        size_mu</span>
<span class="sd">        size_distribution_sigma</span>
<span class="sd">        shape</span>
<span class="sd">        data</span>
<span class="sd">        trace</span>
<span class="sd">        absorption_coefficient</span>
<span class="sd">        molar_absorption_coefficient</span>
<span class="sd">        spatr</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># unpack the tuple that is passed by a call to the partial function</span>
    <span class="p">(</span><span class="n">v_cm1</span><span class="p">,</span><span class="n">crystalPermittivity</span><span class="p">)</span> <span class="o">=</span> <span class="n">atuple</span>
    <span class="c1"># convert the size to a dimensionless number which is 2*pi*size/lambda</span>
    <span class="n">lambda_mu</span> <span class="o">=</span> <span class="mf">1.0E4</span> <span class="o">/</span> <span class="p">(</span><span class="n">v_cm1</span> <span class="o">+</span> <span class="mf">1.0e-12</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size_mu</span> <span class="o">&lt;</span> <span class="mf">1.0e-12</span><span class="p">:</span>
        <span class="n">size_mu</span> <span class="o">=</span> <span class="mf">1.0e-12</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">size_mu</span> <span class="o">/</span> <span class="n">lambda_mu</span>
    <span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># Calculate the permittivity of the matrix as an isotropic tensor at v_cm1</span>
    <span class="n">dielectric_medium</span> <span class="o">=</span> <span class="n">matrixPermittivityFunction</span><span class="p">(</span><span class="n">v_cm1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># Calculate the crystal permittivity at this frequency</span>
    <span class="n">crystal_permittivity</span><span class="o">=</span> <span class="n">crystalPermittivity</span>
    <span class="c1"># Calculate the effect of bubbles in the matrix by embedding in dielectric medium</span>
    <span class="n">refractive_index</span> <span class="o">=</span> <span class="n">calculate_refractive_index</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">refractive_index</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">refractive_index</span> <span class="o">=</span> <span class="n">refractive_index</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">bubble_vf</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">refractive_index</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0e-12</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: only the real part of the support matrix permittivity will be used for Mie Scattering&quot;</span><span class="p">,</span><span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">effdielec</span><span class="p">,</span><span class="n">refractive_index</span> <span class="o">=</span> <span class="n">calculate_bubble_refractive_index</span><span class="p">(</span><span class="n">v_cm1</span><span class="p">,</span> <span class="n">refractive_index</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">bubble_vf</span><span class="p">,</span> <span class="n">bubble_radius</span><span class="p">)</span>
        <span class="n">dielectric_medium</span> <span class="o">=</span> <span class="n">effdielec</span>
    <span class="c1"># Choose which method to apply, the effective dielectric determined with bubbles will be used</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;balan&quot;</span><span class="p">:</span>
        <span class="n">effdielec</span> <span class="o">=</span> <span class="n">balan</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span> <span class="s2">&quot;ap&quot;</span><span class="p">,</span> <span class="s2">&quot;averagedpermittivity&quot;</span><span class="p">,</span> <span class="s2">&quot;averaged permittivity&quot;</span><span class="p">,</span> <span class="s2">&quot;average permittivity&quot;</span> <span class="p">):</span>
            <span class="n">effdielec</span> <span class="o">=</span> <span class="n">averaged_permittivity</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span> <span class="s2">&quot;maxwell&quot;</span><span class="p">,</span> <span class="s2">&quot;maxwell-garnett&quot;</span> <span class="p">):</span>
        <span class="n">effdielec</span> <span class="o">=</span> <span class="n">maxwell</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;maxwell_sihvola&quot;</span><span class="p">:</span>
        <span class="n">effdielec</span> <span class="o">=</span> <span class="n">maxwell_sihvola</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;coherent&quot;</span><span class="p">:</span>
        <span class="n">eff</span>  <span class="o">=</span> <span class="n">previous_solution_shared</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">eff</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.0e-8</span><span class="p">:</span>
            <span class="n">eff</span> <span class="o">=</span> <span class="n">maxwell</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">effdielec</span> <span class="o">=</span> <span class="n">coherent</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">eff</span><span class="p">)</span>
        <span class="n">previous_solution_shared</span> <span class="o">=</span> <span class="n">effdielec</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bruggeman_minimise&quot;</span><span class="p">:</span>
        <span class="n">eff</span>  <span class="o">=</span> <span class="n">previous_solution_shared</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">eff</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.0e-8</span><span class="p">:</span>
            <span class="n">eff</span> <span class="o">=</span> <span class="n">maxwell</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">effdielec</span> <span class="o">=</span> <span class="n">bruggeman_minimise</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">eff</span><span class="p">)</span>
        <span class="n">previous_solution_shared</span> <span class="o">=</span> <span class="n">effdielec</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span> <span class="s2">&quot;bruggeman&quot;</span><span class="p">,</span> <span class="s2">&quot;bruggeman_iter&quot;</span><span class="p">):</span>
        <span class="n">eff</span>  <span class="o">=</span> <span class="n">previous_solution_shared</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">eff</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.0e-8</span><span class="p">:</span>
            <span class="n">eff</span> <span class="o">=</span> <span class="n">maxwell</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">effdielec</span> <span class="o">=</span> <span class="n">bruggeman_iter</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">eff</span><span class="p">)</span>
        <span class="n">previous_solution_shared</span> <span class="o">=</span> <span class="n">effdielec</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;anisotropic-mie&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">refractive_index</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0E-6</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: only the real part of the support matrix permittivity will be used for Mie Scattering&quot;</span><span class="p">,</span><span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">effdielec</span> <span class="o">=</span> <span class="n">anisotropic_mie_scattering</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">size_mu</span><span class="p">,</span> <span class="n">size_distribution_sigma</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;mie&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">refractive_index</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0E-6</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: only the real part of the support matrix permittivity will be used for Mie Scattering&quot;</span><span class="p">,</span><span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">effdielec</span> <span class="o">=</span> <span class="n">mie_scattering</span><span class="p">(</span><span class="n">dielectric_medium</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">crystal_permittivity</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">size_mu</span><span class="p">,</span> <span class="n">size_distribution_sigma</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unkown dielectric method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Average over all directions by taking the trace</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="p">(</span><span class="n">effdielec</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">effdielec</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">effdielec</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="n">refractive_index</span> <span class="o">=</span> <span class="n">calculate_refractive_index</span><span class="p">(</span><span class="n">effdielec</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># absorption coefficient is calculated from the imaginary refractive index</span>
    <span class="c1"># see H.C. van de Hulst Light Scattering by Small Particles , page 267</span>
    <span class="c1"># This is different but related to Genzel and Martin Equation 16, Phys. Stat. Sol. 51(1972) 91-</span>
    <span class="c1"># I&#39;ve add a factor of log10(e) because we need to assume a decadic Beer&#39;s law</span>
    <span class="c1"># units are cm-1</span>
    <span class="n">absorption_coefficient</span> <span class="o">=</span> <span class="n">v_cm1</span> <span class="o">*</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>
    <span class="c1"># units are cm-1 L moles-1</span>
    <span class="n">molar_absorption_coefficient</span> <span class="o">=</span> <span class="n">absorption_coefficient</span> <span class="o">/</span> <span class="n">concentration</span> <span class="o">/</span> <span class="n">vf</span>
    <span class="c1"># calculate the ATR reflectance</span>
    <span class="n">spatr</span> <span class="o">=</span> <span class="n">reflectance_atr</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span><span class="n">atrPermittivity</span><span class="p">,</span><span class="n">atrTheta</span><span class="p">,</span><span class="n">atrSPol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v_cm1</span><span class="p">,</span><span class="n">method</span><span class="p">,</span><span class="n">size_mu</span><span class="p">,</span><span class="n">size_distribution_sigma</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">trace</span><span class="p">,</span><span class="n">absorption_coefficient</span><span class="p">,</span><span class="n">molar_absorption_coefficient</span><span class="p">,</span><span class="n">spatr</span></div>

<div class="viewcode-block" id="calculate_bubble_refractive_index"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.calculate_bubble_refractive_index">[docs]</a><span class="k">def</span> <span class="nf">calculate_bubble_refractive_index</span><span class="p">(</span><span class="n">v_cm1</span><span class="p">,</span> <span class="n">ri_medium</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">radius_mu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the scattering from bubbles embedded in a possibly complex dielectric at a given frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v_cm1 : float</span>
<span class="sd">        The frequency in cm-1.</span>
<span class="sd">    ri_medium : float</span>
<span class="sd">        The refractive index of the medium.</span>
<span class="sd">    vf : float</span>
<span class="sd">        The volume fraction of bubbles.</span>
<span class="sd">    radius_mu : float</span>
<span class="sd">        The radius of the bubbles in microns.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    effective_dielectric_constant : float</span>
<span class="sd">        The effective dielectric constant.</span>
<span class="sd">    ri_medium : float</span>
<span class="sd">        The refractive index of the medium</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function calculates the scattering from bubbles embedded in a dielectric medium, which can have a complex refractive index. It considers the frequency of interest, the refractive index of the medium, the volume fraction of bubbles, and the radius of the bubbles to calculate the effective dielectric constant and its associated refractive index.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># We need to taken account of the change in wavelength and the change in size parameter due to the</span>
    <span class="c1"># None unit value of the dielectric of the embedding medium</span>
    <span class="c1"># The size parameter is 2pi r / lambda</span>
    <span class="c1"># The effective lambda in the supporting medium is lambda / sqrt(emedium)</span>
    <span class="c1"># Where the refractive index is taken to be sqrt(emedium) (non magnetic materials)</span>
    <span class="c1">#</span>
    <span class="n">lambda_vacuum_nm</span> <span class="o">=</span> <span class="mf">1000.0</span> <span class="o">*</span> <span class="mf">10000.0</span> <span class="o">/</span> <span class="n">v_cm1</span> <span class="k">if</span> <span class="n">v_cm1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1e+99</span>
    <span class="c1"># Treat the bubble as though it is air in matrix</span>
    <span class="c1"># The effective wave number k = sqrt(emedium)*2pi*v/c (complex!)</span>
    <span class="n">radius_nm</span> <span class="o">=</span> <span class="n">radius_mu</span> <span class="o">*</span> <span class="mi">1000</span>
    <span class="c1"># volume of a bubble in nm^3</span>
    <span class="n">V_nm</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">/</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius_nm</span> <span class="o">*</span> <span class="n">radius_nm</span> <span class="o">*</span> <span class="n">radius_nm</span>
    <span class="c1"># Number density of bubbles (number / nm^3)</span>
    <span class="n">N_nm</span> <span class="o">=</span> <span class="n">vf</span> <span class="o">/</span> <span class="n">V_nm</span>
    <span class="n">k_nm</span> <span class="o">=</span> <span class="n">waterman_truell_scattering</span><span class="p">(</span><span class="n">lambda_vacuum_nm</span><span class="p">,</span> <span class="n">N_nm</span><span class="p">,</span> <span class="n">radius_nm</span><span class="p">,</span> <span class="n">ri_medium</span><span class="p">)</span>
    <span class="c1"># k_nm = foldy_scattering(lambda_vacuum_nm, N_nm, radius_nm, ri_medium)</span>
    <span class="n">ri_medium</span> <span class="o">=</span> <span class="n">k_nm</span> <span class="o">*</span><span class="n">lambda_vacuum_nm</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">eff_medium</span> <span class="o">=</span> <span class="n">ri_medium</span> <span class="o">*</span> <span class="n">ri_medium</span>
    <span class="n">effdielec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">eff_medium</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">eff_medium</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eff_medium</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">effdielec</span><span class="p">,</span><span class="n">ri_medium</span></div>

<span class="k">def</span> <span class="nf">foldy_scattering</span><span class="p">(</span><span class="n">lambda_vacuum_nm</span><span class="p">,</span> <span class="n">N_nm</span><span class="p">,</span><span class="n">radius_nm</span><span class="p">,</span><span class="n">ri_medium</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the new wave number based on the Foldy&#39;s approximation for light scattering.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lambda_vacuum_nm : float</span>
<span class="sd">        The wavelength of light in vacuum in nanometers.</span>
<span class="sd">    N_nm : float</span>
<span class="sd">        The concentration of scatterers in inverse cubic nanometers.</span>
<span class="sd">    radius_nm : float</span>
<span class="sd">        The.radius of the scatterer in nanometers.</span>
<span class="sd">    ri_medium : float</span>
<span class="sd">        The refractive index of the medium.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_k : complex</span>
<span class="sd">        The new wave number corrected for scattering effects.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function computes a new wave number based on the original wave number,</span>
<span class="sd">    scatterer size, scatterer refractive index, and scatterer concentration using</span>
<span class="sd">    Foldy&#39;s approximation. This involves Mie scattering calculations to determine</span>
<span class="sd">    the scattering coefficients, which are then used to adjust the wave number in</span>
<span class="sd">    the medium accounting for collective scattering effects.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    The implementation and theoretical background can be found in:</span>
<span class="sd">    - L. Foldy, &quot;The Multiple Scattering of Waves. I. General Theory of Isotropic</span>
<span class="sd">    Scattering by Randomly Distributed Scatterers,&quot; Phys. Rev. 67, 107–119 (1945).</span>
<span class="sd">    - Mie scattering theory.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Mie.MieS1S2 : Function used to calculate scattering coefficients based on Mie theory.</span>

<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">k_nm</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">ri_medium</span><span class="o">/</span><span class="n">lambda_vacuum_nm</span>
    <span class="c1"># The size parameter is now also complex and dimensionless</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">k_nm</span><span class="o">*</span><span class="n">radius_nm</span>
    <span class="n">refractive_index</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">ri_medium</span>
    <span class="c1"># Calculate the forward and backward scattering amplitude</span>
    <span class="n">s10</span><span class="p">,</span><span class="n">s20</span> <span class="o">=</span> <span class="n">Mie</span><span class="o">.</span><span class="n">MieS1S2</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="n">ri_medium</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">s10</span> <span class="o">/</span> <span class="n">k_nm</span>
    <span class="n">new_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">k_nm</span><span class="o">*</span><span class="n">k_nm</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">N_nm</span><span class="o">*</span><span class="n">f0</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">new_k</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">new_k</span> <span class="o">=</span> <span class="n">new_k</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">new_k</span>

<div class="viewcode-block" id="waterman_truell_scattering"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.waterman_truell_scattering">[docs]</a><span class="k">def</span> <span class="nf">waterman_truell_scattering</span><span class="p">(</span><span class="n">lambda_vacuum_nm</span><span class="p">,</span> <span class="n">N_nm</span><span class="p">,</span><span class="n">radius_nm</span><span class="p">,</span><span class="n">ri_medium</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the effective wavenumber based on Waterman-Truell scattering model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lambda_vacuum_nm : float</span>
<span class="sd">        Wavelength of the incident light in vacuum, in nanometers.</span>
<span class="sd">    N_nm : float</span>
<span class="sd">        Number density of scatterers, in inverse cubic nanometers.</span>
<span class="sd">    radius_nm : float</span>
<span class="sd">        Radius of a scatterer, in nanometers.</span>
<span class="sd">    ri_medium : float</span>
<span class="sd">        Refractive index of the medium.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_k : complex</span>
<span class="sd">        The complex effective wavenumber calculated based on the Waterman-Truell</span>
<span class="sd">        scattering model, which accounts for the multiple scattering effects</span>
<span class="sd">        among the particles in the medium.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Waterman-Truell scattering model is a method to calculate the effective</span>
<span class="sd">    wavenumber of a medium containing scatterers. This calculation takes into</span>
<span class="sd">    account the size of the scatterers, their number density, and the refractive</span>
<span class="sd">    index of the medium.</span>

<span class="sd">    The model utilizes the Mie scattering solutions to evaluate the forward scattering</span>
<span class="sd">    amplitudes, which are then used to approximate the effective wavenumber for</span>
<span class="sd">    wave propagation in the medium. This model is particularly useful in the study</span>
<span class="sd">    of wave scattering in composite materials and biological tissues.</span>

<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">k_nm</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">ri_medium</span><span class="o">/</span><span class="n">lambda_vacuum_nm</span>
    <span class="c1"># The size parameter is now also complex and dimensionless</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">k_nm</span><span class="o">*</span><span class="n">radius_nm</span>
    <span class="n">refractive_index</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">ri_medium</span>
    <span class="c1"># Calculate the forward and backward scattering amplitude</span>
    <span class="n">s10</span><span class="p">,</span><span class="n">s20</span> <span class="o">=</span> <span class="n">Mie</span><span class="o">.</span><span class="n">MieS1S2</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="n">ri_medium</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">s11</span><span class="p">,</span><span class="n">s21</span> <span class="o">=</span> <span class="n">Mie</span><span class="o">.</span><span class="n">MieS1S2</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="n">ri_medium</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># the normalisation by 1/k_nm is performed when f is calculated</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">s10</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">s11</span>
    <span class="c1"># print(&#39;Waterman_truell&#39;,abs(f0+f1))</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">k_nm</span><span class="o">*</span><span class="n">k_nm</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">N_nm</span><span class="o">/</span><span class="p">(</span><span class="n">k_nm</span><span class="o">*</span><span class="n">k_nm</span><span class="o">*</span><span class="n">k_nm</span><span class="p">)</span>
    <span class="n">new_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">k2</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">f</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">f</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">f1</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">f1</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">new_k</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">new_k</span> <span class="o">=</span> <span class="n">new_k</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">new_k</span></div>

<div class="viewcode-block" id="calculate_centre_of_mass"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.calculate_centre_of_mass">[docs]</a><span class="k">def</span> <span class="nf">calculate_centre_of_mass</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">masses</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Calculate centre of mass.</span>

<span class="sd">   Parameters</span>
<span class="sd">   ----------</span>
<span class="sd">   xyzs : list of xyz coordinates of the atoms</span>
<span class="sd">       The xyz coordinates</span>
<span class="sd">   masses : list of the atomic masses</span>
<span class="sd">       The list of atomic masses in amu</span>

<span class="sd">   Returns</span>
<span class="sd">   -------</span>
<span class="sd">   mass : float - The total mass</span>
<span class="sd">   cm   : vector (3) - the coordinates of the centre of mass</span>

<span class="sd">   &quot;&quot;&quot;</span>
   <span class="n">cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">mass</span> <span class="o">=</span> <span class="mf">0.0</span>
   <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">xyz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">masses</span><span class="p">,</span><span class="n">xyzs</span><span class="p">):</span>
       <span class="n">mass</span> <span class="o">+=</span> <span class="n">m</span>
       <span class="n">cm</span>   <span class="o">+=</span> <span class="n">m</span><span class="o">*</span><span class="n">xyz</span>
   <span class="n">cm</span> <span class="o">/=</span> <span class="n">mass</span>
   <span class="k">return</span> <span class="n">mass</span><span class="p">,</span><span class="n">cm</span></div>

<div class="viewcode-block" id="orthogonalise_projection_operator"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.orthogonalise_projection_operator">[docs]</a><span class="k">def</span> <span class="nf">orthogonalise_projection_operator</span><span class="p">(</span><span class="n">ps</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Orthogonalise the list of projection operators ps.</span>

<span class="sd">   Use Gramm Schmidt orthogonalisation to perform the operation</span>

<span class="sd">   Parameters</span>
<span class="sd">   ----------</span>
<span class="sd">   ps : list of operators</span>
<span class="sd">       The projection operators to orthogonalise.</span>

<span class="sd">   Returns</span>
<span class="sd">   -------</span>
<span class="sd">   out : list of operators</span>
<span class="sd">       The orthogonalised projection operators.</span>

<span class="sd">   Notes</span>
<span class="sd">   -----</span>
<span class="sd">   This function orthogonalises a set of projection operators.</span>

<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># The projection operator has dimension [6,natoms*3]</span>
   <span class="n">maxcyc</span> <span class="o">=</span> <span class="mi">10</span>
   <span class="n">cycle</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="n">max_overlap</span> <span class="o">=</span> <span class="mf">1.0</span>
   <span class="k">while</span> <span class="n">cycle</span> <span class="o">&lt;</span> <span class="n">maxcyc</span> <span class="ow">and</span> <span class="n">max_overlap</span> <span class="o">&gt;</span> <span class="mf">1.0E-8</span><span class="p">:</span>
       <span class="n">cycle</span> <span class="o">+=</span> <span class="mi">1</span>
       <span class="n">max_overlap</span> <span class="o">=</span> <span class="mf">0.0</span>
       <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps</span><span class="p">):</span>
           <span class="c1"># Normalise the projection operator</span>
           <span class="n">anorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
           <span class="n">shift</span> <span class="o">=</span> <span class="mf">0.0</span>
           <span class="k">if</span> <span class="n">anorm</span> <span class="o">&lt;</span> <span class="mf">1.0e-12</span><span class="p">:</span>
               <span class="n">shift</span> <span class="o">=</span> <span class="mf">1.0E-12</span>
           <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">shift</span> <span class="p">)</span>
           <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
           <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">q</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps</span><span class="p">):</span>
               <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                   <span class="c1"># Gramm Schmidt orthogonoalisation</span>
                   <span class="n">dotprod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
                   <span class="n">ps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">dotprod</span><span class="o">*</span><span class="n">p</span>
                   <span class="k">if</span> <span class="n">max_overlap</span> <span class="o">&lt;</span> <span class="n">dotprod</span><span class="p">:</span>
                       <span class="n">max_overlap</span> <span class="o">=</span> <span class="n">dotprod</span>
   <span class="k">if</span> <span class="n">cycle</span> <span class="o">&gt;=</span> <span class="n">maxcyc</span><span class="p">:</span>
       <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING Schmidt Orthogonalisation Failed&quot;</span><span class="p">,</span> <span class="n">max_overlap</span><span class="p">)</span>
       <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
   <span class="k">return</span> <span class="n">ps</span></div>

<div class="viewcode-block" id="construct_projection_operator"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.construct_projection_operator">[docs]</a><span class="k">def</span> <span class="nf">construct_projection_operator</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">xyzs</span><span class="p">,</span> <span class="n">masses</span><span class="p">,</span> <span class="n">nats</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Construct the projection operator for the molecule defined by atoms, xyz, masses.</span>

<span class="sd">   Parameters</span>
<span class="sd">   ----------</span>
<span class="sd">   atoms : list strings</span>
<span class="sd">       The atom types</span>
<span class="sd">   xyzs : list of atom coordinates vector (3)</span>
<span class="sd">       The list of coordinates</span>
<span class="sd">   masses : list of atom masses</span>
<span class="sd">       The list of atomic masses in amu</span>
<span class="sd">   nats : int</span>
<span class="sd">       The number of atoms</span>

<span class="sd">   Returns</span>
<span class="sd">   -------</span>
<span class="sd">   type</span>
<span class="sd">       Description of the returned object.</span>

<span class="sd">   &quot;&quot;&quot;</span>
   <span class="n">mass</span><span class="p">,</span><span class="n">cm</span> <span class="o">=</span> <span class="n">calculate_centre_of_mass</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span><span class="n">masses</span><span class="p">)</span>
   <span class="c1"># The projection operator has dimension number_of_constraints*natoms*3</span>
   <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">nats</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
   <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="n">z</span> <span class="o">=</span> <span class="mi">2</span>
   <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">mass</span><span class="p">,</span><span class="n">xyz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span><span class="n">masses</span><span class="p">,</span><span class="n">xyzs</span><span class="p">):</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mass</span><span class="p">)</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mass</span><span class="p">)</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mass</span><span class="p">)</span>
       <span class="c1"># coordinates relative to the centre of mass</span>
       <span class="n">relxyz</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mass</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">cm</span><span class="p">)</span>
       <span class="c1"># First rotations about x in the y/z plane</span>
       <span class="c1"># zz is really r*sin(theta), and sin(theta) = zz/r</span>
       <span class="c1"># yy is really r*cos(theta), and cos(theta) = yy/r</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">relxyz</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">relxyz</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
       <span class="c1"># Next rotations about y in the x/z plane</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">relxyz</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">relxyz</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
       <span class="c1"># Next rotations about z in the x/y plane</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">relxyz</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">relxyz</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
       <span class="n">ps</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
   <span class="k">return</span> <span class="n">ps</span></div>

<div class="viewcode-block" id="calculate_energy_distribution"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.calculate_energy_distribution">[docs]</a><span class="k">def</span> <span class="nf">calculate_energy_distribution</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">normal_modes</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Calculate energy distribution in the phonon modes.</span>

<span class="sd">   Parameters</span>
<span class="sd">   ----------</span>
<span class="sd">   cell : unit cell object</span>
<span class="sd">       The unit cell object</span>
<span class="sd">   frequencies : array_like</span>
<span class="sd">       The frequencies in cm-1.</span>
<span class="sd">   normal_modes : array_like</span>
<span class="sd">       The mass weighted normal modes.</span>
<span class="sd">   debug : boolean</span>
<span class="sd">       True for debugging</span>

<span class="sd">   &quot;&quot;&quot;</span>
   <span class="n">molecules</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">molecules</span>
   <span class="n">atomic_masses</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">atomic_masses</span>
   <span class="n">xyz</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">xyz_coordinates</span>
   <span class="n">nats</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
   <span class="c1"># Calculate the projections operators for each molecule</span>
   <span class="n">molecular_projection_operators</span> <span class="o">=</span> <span class="p">[]</span>
   <span class="n">molecule_masks</span> <span class="o">=</span> <span class="p">[]</span>
   <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">molecules</span><span class="p">:</span>
       <span class="n">mol_xyzs</span>  <span class="o">=</span> <span class="p">[</span> <span class="n">xyz</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]</span>
       <span class="n">mol_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nats</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
           <span class="n">mol_mask</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">atom</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
           <span class="n">mol_mask</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">atom</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
           <span class="n">mol_mask</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">atom</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
       <span class="n">mol_masses</span> <span class="o">=</span> <span class="p">[</span> <span class="n">atomic_masses</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]</span>
       <span class="n">projection_operators</span> <span class="o">=</span> <span class="n">construct_projection_operator</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span><span class="n">mol_xyzs</span><span class="p">,</span><span class="n">mol_masses</span><span class="p">,</span><span class="n">nats</span><span class="p">)</span>
       <span class="n">projection_operators</span> <span class="o">=</span> <span class="n">orthogonalise_projection_operator</span><span class="p">(</span><span class="n">projection_operators</span><span class="p">)</span>
       <span class="n">molecular_projection_operators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">projection_operators</span><span class="p">)</span>
       <span class="c1">#</span>
       <span class="n">molecule_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol_mask</span><span class="p">)</span>
   <span class="c1"># Calculate the contributions to the kinetic energy in each mode</span>
   <span class="n">energies_in_modes</span> <span class="o">=</span> <span class="p">[]</span>
   <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">normal_modes</span><span class="p">:</span>
       <span class="n">mode_cm</span> <span class="o">=</span> <span class="n">mode</span>
       <span class="n">centre_of_mass_energy</span> <span class="o">=</span> <span class="mf">0.0</span>
       <span class="n">rotational_energy</span> <span class="o">=</span> <span class="mf">0.0</span>
       <span class="n">molecular_energies</span> <span class="o">=</span> <span class="p">[]</span>
       <span class="k">for</span> <span class="n">ps</span><span class="p">,</span><span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">molecular_projection_operators</span><span class="p">,</span><span class="n">molecule_masks</span><span class="p">):</span>
           <span class="c1"># Calculate total kinetic energy</span>
           <span class="n">total_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
           <span class="c1"># Project out centre of mass motion of each molecule</span>
           <span class="n">mode_cm</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="n">ps</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">ps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="n">ps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">ps</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
           <span class="n">centre_of_mass_energy</span> <span class="o">+=</span> <span class="n">total_energy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mode_cm</span><span class="p">,</span><span class="n">mode_cm</span><span class="p">)</span>
           <span class="c1"># Project out molecular rotation of each molecule</span>
           <span class="n">mode_cm</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="n">ps</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">ps</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="n">ps</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">*</span><span class="n">ps</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="n">ps</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="o">*</span><span class="n">ps</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
           <span class="n">rotational_energy</span> <span class="o">+=</span> <span class="n">total_energy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mode_cm</span><span class="p">,</span><span class="n">mode_cm</span><span class="p">)</span>
           <span class="c1"># Now work out the energy of the molecule</span>
           <span class="n">mode_cm</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">mode</span>
           <span class="n">mol_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mode_cm</span><span class="p">,</span><span class="n">mode_cm</span><span class="p">)</span>
           <span class="n">molecular_energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol_energy</span><span class="p">)</span>
       <span class="c1"># end for ps,mask</span>
       <span class="n">vibrational_energy</span> <span class="o">=</span> <span class="n">total_energy</span> <span class="o">-</span> <span class="n">centre_of_mass_energy</span> <span class="o">-</span> <span class="n">rotational_energy</span>
       <span class="n">energies_in_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">total_energy</span><span class="p">,</span><span class="n">centre_of_mass_energy</span><span class="p">,</span><span class="n">rotational_energy</span><span class="p">,</span><span class="n">vibrational_energy</span><span class="p">,</span><span class="n">molecular_energies</span><span class="p">)</span> <span class="p">)</span>
   <span class="c1"># end for mode in normal modes</span>
   <span class="k">return</span> <span class="n">energies_in_modes</span></div>
<span class="c1"># end def</span>


<div class="viewcode-block" id="hodrick_prescott_filter"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.hodrick_prescott_filter">[docs]</a><span class="k">def</span> <span class="nf">hodrick_prescott_filter</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">damping</span><span class="p">,</span><span class="n">lambda_value</span><span class="p">,</span><span class="n">niters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a Hodrick Prescott filter to the spectrum in x, y.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array_like</span>
<span class="sd">        The experimental absorption data.</span>
<span class="sd">    damping : float</span>
<span class="sd">        The damping factor used to damp the iterations.</span>
<span class="sd">    lambda_value : float</span>
<span class="sd">        The chosen smoothing factor.</span>
<span class="sd">    niters : int</span>
<span class="sd">        The number of iterations</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of floats : The new spectrum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on ideas in the thesis of Mayank Kaushik (University Adelaide).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
    <span class="c1">#</span>
    <span class="c1"># Create a sparse 3rd order difference operator</span>
    <span class="c1">#</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">diag</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">diag</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">diag</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">diag</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">3</span> <span class="p">)</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">niters</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="c1"># Problems with overflow if lambda is large</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">lambda_value</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning overflow in Hodrick Prescott filter&quot;</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">damping</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">&gt;</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">damping</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">&lt;</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">z</span></div>

<div class="viewcode-block" id="reflectance_atr"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.reflectance_atr">[docs]</a><span class="k">def</span> <span class="nf">reflectance_atr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span><span class="n">n0</span><span class="p">,</span><span class="n">theta</span><span class="p">,</span><span class="n">atrSPolFraction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the atr s and p reflectance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ns : complex</span>
<span class="sd">        The complex permittivity of the effective medium.</span>
<span class="sd">    n0 : complex</span>
<span class="sd">        The permittivity of atr material.</span>
<span class="sd">    theta : float</span>
<span class="sd">        The angle of incidence in degrees.</span>
<span class="sd">    atrSPolFraction : float</span>
<span class="sd">        The fraction of S wave to be considered. The amount of P wave is 1 - atrSPolFraction.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rs : float</span>
<span class="sd">        The s-wave Fresnel amplitude.</span>
<span class="sd">    rp : float</span>
<span class="sd">        The p-wave Fresnel amplitude.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert theta to an angle in radians</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">costheta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">sintheta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="c1"># Calculate the Fresnel amplitudes for reflection</span>
    <span class="c1"># Equations taken from p368 of APPLIED SPECTROSCOPY REVIEWS</span>
    <span class="c1"># Vol. 39, No. 3, pp. 365–384, 2004</span>
    <span class="c1"># by Milan Milosevic</span>
    <span class="c1"># DOI: 10.1081/ASR-200030195</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span> <span class="p">(</span><span class="n">n0</span><span class="o">*</span><span class="n">costheta</span> <span class="o">-</span> <span class="n">cmath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ns</span><span class="o">*</span><span class="n">ns</span> <span class="o">-</span> <span class="n">n0</span><span class="o">*</span><span class="n">n0</span><span class="o">*</span><span class="n">sintheta</span><span class="o">*</span><span class="n">sintheta</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">n0</span><span class="o">*</span><span class="n">costheta</span> <span class="o">+</span> <span class="n">cmath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ns</span><span class="o">*</span><span class="n">ns</span> <span class="o">-</span> <span class="n">n0</span><span class="o">*</span><span class="n">n0</span><span class="o">*</span><span class="n">sintheta</span><span class="o">*</span><span class="n">sintheta</span><span class="p">))</span>
    <span class="n">rp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ns</span><span class="o">*</span><span class="n">ns</span><span class="o">/</span><span class="n">n0</span><span class="o">*</span><span class="n">costheta</span> <span class="o">-</span> <span class="n">cmath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ns</span><span class="o">*</span><span class="n">ns</span> <span class="o">-</span> <span class="n">n0</span><span class="o">*</span><span class="n">n0</span><span class="o">*</span><span class="n">sintheta</span><span class="o">*</span><span class="n">sintheta</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">ns</span><span class="o">*</span><span class="n">ns</span><span class="o">/</span><span class="n">n0</span><span class="o">*</span><span class="n">costheta</span> <span class="o">+</span> <span class="n">cmath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ns</span><span class="o">*</span><span class="n">ns</span> <span class="o">-</span> <span class="n">n0</span><span class="o">*</span><span class="n">n0</span><span class="o">*</span><span class="n">sintheta</span><span class="o">*</span><span class="n">sintheta</span><span class="p">))</span>
    <span class="c1"># Calculate the reflectance from the amplitudes - store as a real</span>
    <span class="n">RS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">rs</span> <span class="o">*</span> <span class="n">rs</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
    <span class="n">RP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">rp</span> <span class="o">*</span> <span class="n">rp</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
    <span class="n">RSP</span> <span class="o">=</span> <span class="n">atrSPolFraction</span><span class="o">*</span><span class="n">RS</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">atrSPolFraction</span><span class="p">)</span><span class="o">*</span><span class="n">RP</span>
    <span class="c1"># Now return the extinction</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">RSP</span><span class="p">)</span></div>

<div class="viewcode-block" id="cleanup_symbol"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.cleanup_symbol">[docs]</a><span class="k">def</span> <span class="nf">cleanup_symbol</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a true element from the symbol.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : str</span>
<span class="sd">        The element symbol to be cleaned up</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The cleaned symbol</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="determineEulerAngles"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.determineEulerAngles">[docs]</a><span class="k">def</span> <span class="nf">determineEulerAngles</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
<span class="w">     </span><span class="sd">&quot;&quot;&quot;Determine the euler angles of a rotation matrix.</span>

<span class="sd">     Parameters</span>
<span class="sd">     ----------</span>
<span class="sd">     R : tensor (3,3)</span>
<span class="sd">        The rotation matrix</span>

<span class="sd">     Returns</span>
<span class="sd">     -------</span>
<span class="sd">     theta, phi, psi : float</span>
<span class="sd">        The Euler angles</span>

<span class="sd">     &quot;&quot;&quot;</span>
     <span class="n">R11</span><span class="o">=</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
     <span class="n">R12</span><span class="o">=</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
     <span class="n">R13</span><span class="o">=</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
     <span class="n">R21</span><span class="o">=</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
     <span class="n">R31</span><span class="o">=</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
     <span class="n">R32</span><span class="o">=</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
     <span class="n">R33</span><span class="o">=</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
     <span class="n">phi</span> <span class="o">=</span> <span class="mf">0.0</span>
     <span class="k">if</span> <span class="n">R31</span> <span class="o">&gt;</span> <span class="mf">0.9999999999</span><span class="p">:</span>
         <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span>
         <span class="n">psi</span>   <span class="o">=</span> <span class="o">-</span><span class="n">phi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">R12</span><span class="p">,</span><span class="o">-</span><span class="n">R13</span><span class="p">)</span>
     <span class="k">elif</span> <span class="n">R31</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.9999999999</span><span class="p">:</span>
         <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span>
         <span class="n">psi</span>   <span class="o">=</span> <span class="n">phi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">R12</span><span class="p">,</span><span class="n">R13</span><span class="p">)</span>
     <span class="k">else</span><span class="p">:</span>
         <span class="n">theta</span> <span class="o">=</span> <span class="n">theta1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">R31</span><span class="p">)</span>
         <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">R32</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">),</span> <span class="n">R33</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">))</span>
         <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">R21</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">),</span> <span class="n">R11</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">))</span>
     <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">psi</span></div>

<div class="viewcode-block" id="euler_rotation"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.euler_rotation">[docs]</a><span class="k">def</span> <span class="nf">euler_rotation</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">psi</span><span class="p">):</span>
<span class="w">     </span><span class="sd">&quot;&quot;&quot;Apply a passive Euler rotation to a vector.</span>

<span class="sd">     Parameters</span>
<span class="sd">     ----------</span>
<span class="sd">     vector : vector (3)</span>
<span class="sd">         The vector to be rotated</span>
<span class="sd">     theta  : float</span>
<span class="sd">         The angle theta</span>
<span class="sd">     phi    : float</span>
<span class="sd">         The angle phi</span>
<span class="sd">     psi    : float</span>
<span class="sd">         The angle psi</span>

<span class="sd">     Returns</span>
<span class="sd">     -------</span>
<span class="sd">     vector (3)</span>

<span class="sd">     Notes</span>
<span class="sd">     -----</span>
<span class="sd">     A passive Euler rotation refers to the rotation of the coordinate system </span>
<span class="sd">     while the vector remains fixed. This operation is often used in </span>
<span class="sd">     physics and engineering to describe the orientation of an object </span>
<span class="sd">     with respect to a reference coordinate system.</span>

<span class="sd">     &quot;&quot;&quot;</span>
     <span class="n">euler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
     <span class="n">euler</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
     <span class="n">euler</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
     <span class="n">euler</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
     <span class="n">euler</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
     <span class="n">euler</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
     <span class="n">euler</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
     <span class="n">euler</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
     <span class="n">euler</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
     <span class="n">euler</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">euler</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_pool"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.get_pool">[docs]</a><span class="k">def</span> <span class="nf">get_pool</span><span class="p">(</span><span class="n">ncpus</span><span class="p">,</span> <span class="n">threading</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debugger</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
<span class="w">     </span><span class="sd">&quot;&quot;&quot;Return a pool of processors given the number of cpus and whether threading is requested.</span>

<span class="sd">     Parameters</span>
<span class="sd">     ----------</span>
<span class="sd">     ncpus : int </span>
<span class="sd">        the number of processors</span>
<span class="sd">     threading : bool </span>
<span class="sd">        true if threading is to be used</span>
<span class="sd">     initializer : function</span>
<span class="sd">        Function to be called before getting the pool</span>
<span class="sd">     initargs : function arguments</span>
<span class="sd">        Any other parameters</span>
<span class="sd">     debugger : a debugger object</span>
<span class="sd">        A debugger object</span>

<span class="sd">     Returns</span>
<span class="sd">     -------</span>
<span class="sd">     pool : the pool of processors</span>

<span class="sd">     &quot;&quot;&quot;</span>
     <span class="k">if</span> <span class="n">debugger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="n">debugger</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s2">&quot;get_pool ncpus = &quot;</span><span class="p">,</span><span class="n">ncpus</span><span class="p">)</span>
         <span class="n">debugger</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s2">&quot;get_pool threading = &quot;</span><span class="p">,</span><span class="n">threading</span><span class="p">)</span>
         <span class="n">debugger</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s2">&quot;get_pool initializer = &quot;</span><span class="p">,</span><span class="n">initializer</span><span class="p">)</span>
     <span class="c1"># see if threading has been requested</span>
     <span class="k">if</span> <span class="n">threading</span><span class="p">:</span>
         <span class="kn">from</span> <span class="nn">multiprocessing.dummy</span> <span class="kn">import</span> <span class="n">Pool</span>
         <span class="k">if</span> <span class="n">debugger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
             <span class="n">debugger</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s2">&quot;get_pool using the multiprocessing package and threading&quot;</span><span class="p">)</span>
     <span class="k">else</span><span class="p">:</span>
         <span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
         <span class="k">if</span> <span class="n">debugger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
             <span class="n">debugger</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s2">&quot;get_pool using the multiprocessing package&quot;</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">Pool</span><span class="p">(</span><span class="n">ncpus</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">initializer</span><span class="p">,</span> <span class="n">initargs</span><span class="o">=</span><span class="n">initargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="set_no_of_threads"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.set_no_of_threads">[docs]</a><span class="k">def</span> <span class="nf">set_no_of_threads</span><span class="p">(</span><span class="n">nthreads</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set default number of threads</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ncpus : int the number of threads to be used</span>

<span class="sd">    The environment is modified to set the most common environment variables for the number of threads</span>
<span class="sd">    a BLAS implementation will use.</span>
<span class="sd">    BLAS implementations include: MKL, OPENBLAS, OMP, NUMEXPR, BLIS and VECLIB</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;MKL_NUM_THREADS&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">nthreads</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;OPENBLAS_NUM_THREADS&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">nthreads</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;OMP_NUM_THREADS&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">nthreads</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;NUMEXPR_NUM_THREADS&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">nthreads</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;BLIS_NUM_THREADS&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">nthreads</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;VECLIB_MAXIMUM_THREADS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">nthreads</span><span class="p">)</span></div>

<div class="viewcode-block" id="set_affinity_on_worker"><a class="viewcode-back" href="../../autoapi/PDielec/Calculator/index.html#PDielec.Calculator.set_affinity_on_worker">[docs]</a><span class="k">def</span> <span class="nf">set_affinity_on_worker</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;When a new worker process is created, the affinity is set to all CPUs&#39;&#39;&#39;</span></div>
    <span class="c1">#JK print(&#39;I&#39;m the process %d, setting affinity to all CPUs.&#39; % os.getpid())</span>
    <span class="c1">#JK Commented out for the time being</span>
    <span class="c1">#JK os.system(&#39;taskset -p 0xff %d &gt; /dev/null&#39; % os.getpid())</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, John Kendrick and Andrew Burnett
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=9234fd31"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    </body>
</html>