#!/usr/bin/python2
#
# Copyright 2015 John Kendrick
#
# This file is part of PDielec
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the MIT License 
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
#
# You should have received a copy of the MIT License
# along with this program, if not see https://opensource.org/licenses/MIT
"""Read the contents of a directory containing VASP/Gulp/Castep output and create a csv style file of information"""
import string
import re
import numpy as np
import math 
import os, sys
from Python.Constants import *
from Python.UnitCell import *
from Python.DielectricConstant import *
from Python.VaspOutputReader import *
from Python.CastepOutputReader import *
from Python.GulpOutputReader import *
from Python.Plotter import *


def showUsage():
    print"pdielec [-method ap/balan/maxwell/bruggeman] [-plot molar_absorption]"
    print"        [-sphere] [-needle h k l] [-plate h k l] [-ellipsoid h k l aoverb ]" 
    print"        [-print] [-sigma %f ] [-mode_sigma mode sigma ] " % (sigma)
    print"        [-optical xx yy zz] [-optical_tensor xx yy zz xy xz yz] [-vmin %f] [-vmax %f]" % (vmin,vmax)
    print"        [-vf %f] " % (volume_fraction)
    print"        [-mf %f] " % (mass_fraction)
    print"        [-dielectric %f] [-density %f] " % (matrix_dielectric,matrix_density)
    print"        [-matrix nujol/ptfe/kbr/ldpe/mdpe/hdpe] "
    print"        [-mode index] [-csv file] name"
    print"pdielec: Calculates a spectrum from VASP, CASTEP or GULP"
    print"             In the case of VASP name must be the directory containg results"
    print"             In the case of CASTEP name must be the seed name of the calculation"
    print"             In the case of GULP name must be the output file name of the calculation"
    print"             At least one shape must be specified ( -sphere -needle -plate )"
    print"         -method ap/balan/maxwell/bruggeman/bruggeman_iter/bruggeman_minimise/maxwell_sihvola"
    print"             Choose the method to be used to, balan, maxwell or bruggeman"
    print"             maxwell_sihvola should give the same results as maxwell but could be used to deal with chirality"
    print"             bruggeman and brugemann_iter solve the bruggeman equations iteratively.."
    print"             brugemann_minimise solves the bruggeman equations by minimisation.."
    print"             The option can be used more than once"
    print"         -plot real/imaginary/absorption/molar_absorption"
    print"             The real, imaginary or the absorption coefficent of "
    print"             the dielectric are plotted the default is absorption coefficient"
    print"             The units of absorption coefficient are m-1"
    print"             The option can be used more than once"
    print"         -vf 0.1"
    print"             Include the following number as a volume fraction"
    print"             The option can be used more than once"
    print"         -print"
    print"           print additional information about the calculation"
    print"         -csv file"
    print"           print a csv file"
    print"         -sigma gives the Lorentzian sigma width in wavenumbers default is %f" % sigma
    print"         -mode_sigma mode sigma"
    print"             A given mode is assigned its own width"
    print"             all other modes not specified use the width specified by -sigma"
    print"             The directive can be used many times"
    print"             Warning a mode_sigma command is needed for all degenerate components"
    print"         -matrix ptfe"
    print"             Defines material, density and permittivity of the supporting medium"
    print"             Possible materials are;"
    for f in matrix:
        (rho, eps) = matrix[f]
        print"                 ", f, " density ",rho, " permittivity ", eps
    print"         -dielectric is the dielectric constant of the medium"
    print"             For kbr the value is 2.25"
    print"             For ptfe the value is 2.0"
    print"             For nujol the value is 2.155 (refractive index is 1.468) "
    print"             For vacuum or air the value is 1.0"
    print"         -vmax vmax  report all frequencies from vmin to vmax"
    print"         -vmin vmin  report all frequencies from vmin to vmax"
    print"         -sphere"
    print"             Adds sphere shape to the shapes to be processed"
    print"             The option can be used more than once"
    print"         -needle h k l"
    print"             Adds the needle shape to the shapes to be processed"
    print"             hkl (integers) define the unique needle direction as [hkl]"
    print"             The option can be used more than once"
    print"         -plate h k l" 
    print"             Adds the plate shape to the shapes to be processed"
    print"             hkl (integers) are miller indices, the plate lies in the (hkl) plane"
    print"             for non-orthogonal cells [hkl] and the normal to (hkl) are not necessarily the same"
    print"             The option can be used more than once"
    print"         -ellipsoid h k l aoverb" 
    print"             Adds the ellipsoid shape to the list of shapes to be processed"
    print"             the unique ellipsoid direction is [hkl] "
    print"             aoverb (a/b) is the eccentricity of the ellipsoid"
    print"             oblate ellipsoid eccentricity (a/b) < 1"
    print"             prolate ellipsoid eccentricity (a/b) > 1"
    print"             The option can be used more than once"
    print"         -optical xx yy zz are the optical permitivitties (diagonals) "
    print"             These can be found in the .castep file"
    print"             If the .castep file is present then the values will be read automatically"
    print"             If the tensor is not diagonal use the -optical_tensor flag"
    print"         -optical_tensor xx yy zz xy xz yz is the full optical permitivitty tensor"
    print"             If either optical commands are given on the command line they overide"
    print"             the optical permittivity found in the .castep file"
    print"         -i  step   gives the increment of frequency (0.2 cm-1)"
    print"         -ignore mode"
    print"             Ignore a mode in the construction of the dielectric"
    print"             by default all modes with a frequency less than 5cm-1 are ignored"
    print"             -ignore (can be used more than once) is used only modes specified are ignored"
    print"         -mode  index  only include this mode in the sum"
    print"             This option can be included several times"
    print"             By default all frequencies are included"
    return

# define some constants which may change due to the parameters on the command line
ahalf          = 1.0/2.0
athird         = 1.0/3.0
increment      = 0.2
requests       = []
optical        = []
optical_tensor = []
my_modes       = []
ignore_modes   = []
mode_sigmas    = {}
vmax           = 300.0
vmin           = 0.0
shapes         = []
shape_data     = []
names          = []
methods        = []
volume_fractions = []
mass_fractions = []
mass_fractions_string = []
fractional_types = []
plot_types      = []
volume_fraction = 0.1
mass_fraction = 0.0
sigma          = 5
matrix_dielectric  = 1.00  # air
matrix_dielectric  = 2.25  # kbr
matrix_dielectric  = 2.0   # ptfe
matrix_density = 2.2
printInfo      = False
csvfile        = ""
# Define materials as (density, permittivity)
matrix         =  {}
matrix["air"]    =  (0.0  ,1.0)
matrix["vacuum"] =  (0.0  ,1.0)
matrix["ptfe"]   =  (2.2  ,2.0)
matrix["kbr"]    =  (2.75 ,2.25)
matrix["nujol"]  =  (0.838,2.155)
matrix["hdpe"]   =  (0.925,2.25)
matrix["mdpe"]   =  (0.933,2.25)
matrix["ldpe"]   =  (0.955,2.25)

# Establish the calculator function which will be used for the majority of calculations
calculator = DielectricConstant()

# check usage
if len(sys.argv) <=1:
    showUsage()
    exit()

# Begin processing of command line
commandLine = ' '.join(sys.argv)
tokens = sys.argv[1:]
ntokens = len(tokens)
itoken = 0
#for itoken in range(ntokens):
while itoken < ntokens:
    token = tokens[itoken]
    if token == "-sigma":
        itoken += 1; sigma = float(tokens[itoken])
    elif token == "-print":
        printInfo = True
    elif token == "-mode_sigma":
        itoken += 1; mode = int(tokens[itoken])
        itoken += 1; mode_sigmas[mode] = int(tokens[itoken])
    elif token == "-method":
        itoken += 1; methods.append(tokens[itoken])
    elif token == "-plot":
        itoken += 1; plot_types.append(tokens[itoken])
    elif token == "-vf":
        itoken += 1; volume_fractions.append(float(tokens[itoken]))
        fractional_types.append("vf=%s" % (tokens[itoken]) )
    elif token == "-mf":
        itoken += 1; mass_fractions.append(float(tokens[itoken]))
        mass_fractions_string.append(tokens[itoken])
    elif token == "-dielectric":
        itoken += 1; matrix_dielectric = float(tokens[itoken])
    elif token == "-density":
        itoken += 1; matrix_density = float(tokens[itoken])
    elif token == "-matrix":
        itoken += 1; token = tokens[itoken]
        if token in matrix:
            (matrix_density,matrix_dielectric) = matrix[token]
        else:
            print "Error, unkown material ", token
            exit(1)
    elif token == "-optical":
        optical = [ float(f) for f in tokens[itoken+1:itoken+4] ]
        itoken = itoken + 3
    elif token == "-optical_tensor":
        temp = [ float(f) for f in tokens[itoken+1:itoken+10] ]
        itoken = itoken + 9
        optical_tensor.append(temp[0:3])
        optical_tensor.append(temp[3:6])
        optical_tensor.append(temp[6:9])
    elif token == "-i":
        itoken += 1; increment = float(tokens[itoken])
    elif token == "-mode":
        itoken += 1; my_modes.append(int(tokens[itoken]))
    elif token == "-ignore":
        itoken += 1; ignore_modes.append(int(tokens[itoken]))
    elif token == "-vmin":
        itoken += 1; vmin = float(tokens[itoken])
    elif token == "-vmax":
        itoken += 1; vmax = float(tokens[itoken])
    elif token == "-csv":
        itoken += 1; csvfile = tokens[itoken]
    elif token == "-sphere":
        shapes.append("sphere")
        shape_data.append(" ")
    elif token == "-plate":
        shapes.append("plate")
        itoken += 1; token = tokens[itoken]
        if token[0] == "[" or token[0] =="(" or token[0] == "{" :
            data = token
        else :
            data = "("+token+","+tokens[itoken+1]+","+tokens[itoken+2]+")"
            itoken += 2
        shape_data.append(data)
    elif token == "-ellipsoid":
        shapes.append("ellipsoid")
        itoken += 1; token = tokens[itoken]
        if token[0] == "[" or token[0] =="(" or token[0] == "{" :
            data = token
        else :
            data = "["+token+","+tokens[itoken+1]+","+tokens[itoken+2]+"]"
            itoken += 2
        itoken += 1; aoverb = float(tokens[itoken])
        shape_data.append( (data,aoverb) )
    elif token == "-needle":
        shapes.append("needle")
        itoken += 1; token = tokens[itoken]
        if token[0] == "[" or token[0] =="(" or token[0] == "{" :
            data = token
        else :
            data = "["+token+","+tokens[itoken+1]+","+tokens[itoken+2]+"]"
            itoken += 2
        shape_data.append(data)
    elif token[0] == "-":
        print "Error on input unkown option",token
        exit(1)
    else:
        print 'appending to names ', token
        names.append(token)
    itoken += 1
    # end loop over tokens

# Look for obvious errors
if len(names) <= 0:
      print "No files were specified"
      showUsage()
      exit(1)
if len(shapes) <= 0:
      shapes.append("sphere")
      shape_data.append(" ")
      print "No shapes were specified, using a sphere"

# Set default method
if len(methods) == 0:
    methods.append('maxwell')

# print out information
print "The following methods will be used: ", methods

fd_csvfile = 0
if not csvfile == "":
    print "Creating a csv file: ",csvfile
    fd_csvfile = open(csvfile, 'w')
if len(plot_types) == 0:
    print "No plotting requested"
else:
    print "Plotting types requested are",plot_types
print "The frequency increment is ",increment," cm-1"
print "The default width factor (-sigma) has been set to ",sigma, " cm-1"
if len(mode_sigmas.keys()) > 0:
  for mode in mode_sigmas.keys():
    print "Mode %d has a width factor of %f" % (mode,mode_sigmas[mode])
print "Permittivity of the medium (-dielectric) has been set to ",matrix_dielectric
print "Density of the medium (-density) has been set to ",matrix_density
if len(optical_tensor) > 0:
  print "Optical permitivity tensor specified: ", optical_tensor
if len(optical) > 0:
  print "Optical permitivity diagonal elements specified: ", optical
  optical_tensor = calculator.tensorInitialiseDiagonal( optical )
print "Vmin is: ", vmin
print "Vmax is: ", vmax
if len(my_modes) > 0:
   print "Only consider contributions from modes:", my_modes
else:
   print "Considering all modes"
#
# Arrays will be used where possible from now on, also some arrays will contain complex numbers
#

# Loop over the names from the command line
for name in names:
    #  If name is a directory then we will use a vaspoutputreader
    #  Otherwise it is a seedname for castep, or a gulp output file
    if os.path.isdir(name):
      print 'Analysing VASP directory: ',name
      outcarfile = os.path.join(name,"OUTCAR")
      if not os.path.isfile(outcarfile):
        print "Error: NO OUTCAR FILE IN DIRECTORY"
        exit()
      r = VaspOutputReader(name)
      calculator.setReader(r)
    elif name.find(".gout") >= 0:
      r = GulpOutputReader(name)
      calculator.setReader(r)
    else:
      if name.find(".castep") >= 0:
        seedname,ext = os.path.splitext(name)
      else:
        seedname=name
      castepfile = seedname+".castep"
      print "Castep file ", castepfile
      if not os.path.isfile(castepfile):
        print "Error: NO CASTEP FILE IN DIRECTORY"
        exit()
      #endif
      r = CastepOutputReader(seedname)
      calculator.setReader(r)
    # end if
    if printInfo:
        r.printInfo()
    # Calculate the depolarisation matrices.  Put here because we need the lattice vectors
    depolarisations = []
    for shape, data in zip(shapes,shape_data):
        label = ""
        printd = data
        if shape == "ellipsoid":
            (printd, label) = data
        print "Shape depolarisation matrix: ", shape, printd, label
        if shape == "sphere":
            depolarisations.append( calculator.initialiseSphereDepolarisationMatrix() )
        if shape == "plate":
            direction = calculator.directionFromShape(data)
            depolarisations.append( calculator.initialisePlateDepolarisationMatrix(direction) )
        if shape == "needle":
            direction = calculator.directionFromShape(data)
            depolarisations.append( calculator.initialiseNeedleDepolarisationMatrix(direction) )
        if shape == "ellipsoid":
            ellipsez,aoverb = data
            direction = calculator.directionFromShape(ellipsez)
            depolarisations.append( calculator.initialiseEllipsoidDepolarisationMatrix(direction,aoverb) )
        print depolarisations[-1]
        print
    # Define some of the constants
    dielectric_medium = calculator.tensorInitialiseDiagonal( [ matrix_dielectric, matrix_dielectric, matrix_dielectric ] )
    # access the information as numpy arrays.  Use atomic units for these arrays
    masses = np.array(r.masses) * amu
    mass_weighted_normal_modes = np.array(r.mass_weighted_normal_modes)
    frequencies = np.array(r.frequencies) * wavenumber
    frequencies_cm1 = np.array(r.frequencies) 
    volume = r.volume*angstrom*angstrom*angstrom
    print "Volume of unit cell is ",r.volume, " Angstrom^3"
    mtotal = 0.0
    for m in r.masses :
      mtotal = mtotal + m
    print "Total unit cell mass is: ", mtotal, " g/mol"
    crystal_density = mtotal/( avogadro_si * r.volume * 1.0e-24)
    print "Crystal density is: ", crystal_density, " g/cc"
    rho1 = crystal_density
    rho2 = matrix_density
    # Convert any mass fractions to volume fractions
    if len(mass_fractions) > 0:
        print "The density of the supporting matrix is ", matrix_density, " g/cc"
        print "Converting the following mass fractions to volume fractions"
        for mf1,string in zip(mass_fractions,mass_fractions_string):
            mf2 = 1.0 - mf1
            vf1 = 1.0 / ( 1 + (mf2/mf1) * ( rho1/rho2) )
            volume_fractions.append( vf1 )
            fractional_types.append("mf=%s" % (string) )
            print " The volume fraction for mass fraction ", mf1, " is ", vf1

    # Set default volume fraction if we need to
    if len(volume_fractions) == 0:
        volume_fractions.append(volume_fraction)
        fractional_types.append("vf=%f" % ( volume_fraction) )

    # Get the zero frequency optical tensor from the output
    epsilon_inf = np.array(r.zerof_optical_dielectric)
    # Initialise the zero frequency optical tensor if it was supplied on the command
    if len(optical_tensor) > 0:
        epsilon_inf = np.array(optical_tensor)
    # Get the born charges
    born_charges = np.array(r.born_charges)
    mode_set = []
    sigmas = []
    # set the widths and define the list of modes to me considered
    for imode,frequency in enumerate(r.frequencies):
        mode_set.append(imode)
        sigmas.append(sigma)
    for mode in mode_sigmas.keys():
        sigmas[mode] = mode_sigmas[mode]

    print "Complete mode list is: ", mode_set
    print "Sigmas are  : ", sigmas
    
    # convert sigmas to wavenumbers
    sigmas_cm1 = np.array(sigmas)
    sigmas = np.array(sigmas)*wavenumber

    #born_charges = calculator.BornChargeSumRule(born_charges)
    #print "New Born Charges"
    #print born_charges
    # calculate normal modes in xyz coordinate space
    # should they be re-normalised or not?  According to Balan the mass weighted coordinates should be normalised
    normal_modes = calculator.NormalModes(masses,mass_weighted_normal_modes)
    # from the normal modes and the born charges calculate the oscillator strengths of each mode
    oscillator_strengths = calculator.OscillatorStrengths(normal_modes, born_charges )
    # calculate the intensities from the trace of the oscillator strengths
    intensities = calculator.IRIntensities(oscillator_strengths)
    # Only modes with non-zero oscillator strengths contribute to the dielectric
    # so calculate those modes which we can safely ignore and store them in ignore_modes
    if len(ignore_modes) == 0:
        for mode,intensity in enumerate(intensities):
            # ignore modes with a low oscillator strength
            if intensity < 1.0E-10:
              ignore_modes.append(mode)
            # ignore modes with low real frequency
            elif np.real(frequencies[mode])/wavenumber < 5.0 :
              ignore_modes.append(mode)
            # ignore modes with imaginary frequency
            elif abs(np.imag(frequencies[mode]))/wavenumber > 1.0e-6:
              ignore_modes.append(mode)
            #end if intensity
        #end for 
    # end if len()
    # Remove any unwanted modes
    ignore_modes = set(ignore_modes)
    if len(ignore_modes) > 0:
        for mode in ignore_modes:
            if mode in mode_set:
                mode_set.remove(mode)
        # end loop over modes to be ignored
    # end of if ignore_modes
    # If a selected list of frequencies has been selected then use these
    if len(my_modes) > 0:
        mode_set = set(my_modes)
    print "Selected mode list is: ", mode_set
    #
    print 'Calculated Integrated IR band intensities (espilon_max assumes a fwhm line width)'
    print 'mode,Freq(cm-1),Intensity(Debye2/Angstrom2/amu),Integrated_Molar_Absorption_Coefficient(L/mole/cm/cm),epsilon_max(L/mole/cm), FWHM(cm-1)'
    if fd_csvfile > 0 :
        print >> fd_csvfile, commandLine
        print >> fd_csvfile, 'Calculated Integrated IR band intensities (espilon_max assumes a fwhm line width)'
        print >> fd_csvfile, 'Mode,Freq(cm1),Intensity(Debye2/Angstrom2/amu),Integrated_Molar_Absorption_Coefficient(L/mole/cm/cm),epsilon_max(L/mole/cm),FWHM(cm-1)'
    for m in mode_set :
        f = r.frequencies[m]
        i = intensities[m]
        w = sigmas_cm1[m]
        print m,',',f,',',i,',',4225.6*i,',',2*4225.6*i/w/PI,',',w
        if fd_csvfile > 0 :
             print >> fd_csvfile, m,',',f,',',i,',',4225.6*i,',',2*4225.6*i/w/PI,',',w
    # from the oscillator strengths calculate the low frequency permittivity
    epsilon_ionic = calculator.IonicPermittivity(mode_set, oscillator_strengths, frequencies, volume )
    print 'Permittivity contribution from ionic displacements'
    print epsilon_ionic
    print 'Optical permittivity at zero frequency'
    print epsilon_inf
    epsilon_total = epsilon_inf + epsilon_ionic
    print 'Total permittivity'
    print epsilon_total
    # the concentration of unit cells per 1000 cc can be calculated in moles / L
    concentration = 1000.0 / ( avogadro_si * r.volume * 1.0e-24 )
    print "Concentration for unit volume fraction in moles / Litre", concentration
    # Create a dictionary to hold the last solution for a given method/volume/fraction
    previous_solution={}
    # Create a plotter to plot/print the final data
    plotter = Plotter()
    # Loop over frequencies
    for v in np.arange(float(vmin),float(vmax)+0.5*float(increment),float(increment)):
        # loop over all modes and calculate the contribution to the dielectric
        vau = v * wavenumber
        ionicv = calculator.dielectricContribution(vau,mode_set,frequencies,sigmas,oscillator_strengths,volume)
        # absorption units here are L/mole/cm-1
        molar_absorption_coefficient_from_mode_intensities_Lpmolpcm = calculator.absorptionFromModeIntensities(v,mode_set,frequencies_cm1,sigmas_cm1,intensities)
        # Now the units are cm-1
        absorption_coefficient_from_mode_intensities_pcm = concentration * molar_absorption_coefficient_from_mode_intensities_Lpmolpcm
        dielecv = ionicv + epsilon_inf
        nplot = -1
        # Loop over methods
        for method in methods:
          # Loop over volume_fractions
          for vf,vf_type in zip(volume_fractions,fractional_types):
            # Loop over shapes
            apCount = 0 # Use a counter to only calculate the AveragedPermittivity once for all shapes
            for shape,data,L in zip(shapes,shape_data,depolarisations):
                nplot += 1
                if method == "balan":
                    effdielec = calculator.balan(dielectric_medium,dielecv, shape, L, vf )
                elif method == "ap" or method == "averagedpermittivity" :
                    if apCount == 0:
                        effdielec = calculator.averagedPermittivity(dielectric_medium,dielecv, shape, L, vf  )
                        shape = "noshape"
                        apCount += 1
                    else:
                        nplot -= 1
                        continue
                elif method == "maxwell":
                    effdielec = calculator.maxwell(dielectric_medium, dielecv, shape, L, vf)
                elif method == "maxwell_sihvola":
                    effdielec = calculator.maxwell_sihvola(dielectric_medium, dielecv, shape, L, vf)
                elif method == "coherent":
                    if (method,vf,shape) in previous_solution:
                        eff = previous_solution[method,vf,shape]
                    else:
                        eff = calculator.maxwell(dielectric_medium, dielecv, shape, L, vf)
                    effdielec = calculator.coherent(dielectric_medium, dielecv, shape, L, vf,eff)
                elif method == "bruggeman_minimise":
                    if (method,vf,shape) in previous_solution:
                        eff = previous_solution[method,vf,shape]
                    else:
                        eff = calculator.maxwell(dielectric_medium, dielecv, shape, L, vf)
                    effdielec = calculator.bruggeman_minimise(dielectric_medium, dielecv, shape, L, vf,eff)
                    previous_solution[(method,vf,shape)] = effdielec
                elif method == "bruggeman" or method == "bruggeman_iter":
                    if (method,vf,shape) in previous_solution:
                        eff = previous_solution[method,vf,shape]
                    else:
                        eff = calculator.maxwell(dielectric_medium, dielecv, shape, L, vf)
                    effdielec = calculator.bruggeman_iter(dielectric_medium, dielecv, shape, L, vf,eff)
                    previous_solution[(method,vf,shape)] = effdielec
                else:
                    print 'Unkown dielectric method ',method
                    exit(1)
                # Average over all directions by taking the trace
                trace = (effdielec[0,0] + effdielec[1,1] + effdielec[2,2] ) / 3.0
                refractive_index=calculator.refractive_index(effdielec)
                # absorption coefficient is calculated from the imaginary refractive index
                # see H.C. van de Hulst Light Scattering by Small Particles , page 267
                # This is different but related to Genzel and Martin Equation 16, Phys. Stat. Sol. 51(1972) 91-
                # I've add a factor of log10(e) because we need to assume a decadic Beer's law
                # units are cm-1
                absorption_coefficient = v * 4*PI * np.imag(refractive_index) * math.log10(math.e)
                # units are cm-1 L moles-1
                molar_absorption_coefficient = absorption_coefficient / concentration / vf
                plotter.addDielectric(nplot,method,vf_type,shape,data,v,trace,absorption_coefficient,molar_absorption_coefficient)
            # end of loop over shapes
          # end of loop over volume fractions
        # end of loops over methods
        # Calculate TO contribution to loss
        trace = (dielecv[0,0] + dielecv[1,1] + dielecv[2,2] ) / 3.0
        #  Scale the output to use a volume fraction so plots are comparable
        # absorption_coefficient_from_mode_intensities_pcm *= vf
        # plotter.addDielectric(nplot,'TOs_from_intensities',vf,'noshape','',v,trace_pure,absorption_coefficient_from_mode_intensities_pcm,molar_absorption_coefficient_from_mode_intensities_Lpmolpcm)
    # end of look over frequencies
    plotter.printout(fd_csvfile)
    if fd_csvfile > 0:
        fd_csvfile.close()
    plotter.plot(plot_types)
